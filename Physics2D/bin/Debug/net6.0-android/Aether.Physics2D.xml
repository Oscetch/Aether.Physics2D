<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Aether.Physics2D</name>
    </assembly>
    <members>
        <member name="T:tainicom.Aether.Physics2D.Collision.ContactFeature">
            <summary>
            The features that intersect to form the contact point
            This must be 4 bytes or less.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.ContactFeature.IndexA">
            <summary>
            Feature index on ShapeA
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.ContactFeature.IndexB">
            <summary>
            Feature index on ShapeB
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.ContactFeature.TypeA">
            <summary>
            The feature type on ShapeA
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.ContactFeature.TypeB">
            <summary>
            The feature type on ShapeB
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.ContactID">
            <summary>
            Contact ids to facilitate warm starting.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.ContactID.Features">
            <summary>
            The features that intersect to form the contact point
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.ContactID.Key">
            <summary>
            Used to quickly compare contact ids.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.ManifoldPoint">
            <summary>
            A manifold point is a contact point belonging to a contact
            manifold. It holds details related to the geometry and dynamics
            of the contact points.
            The local point usage depends on the manifold type:
            -ShapeType.Circles: the local center of circleB
            -SeparationFunction.FaceA: the local center of cirlceB or the clip point of polygonB
            -SeparationFunction.FaceB: the clip point of polygonA
            This structure is stored across time steps, so we keep it small.
            Note: the impulses are used for internal caching and may not
            provide reliable contact forces, especially for high speed collisions.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.ManifoldPoint.Id">
            <summary>
            Uniquely identifies a contact point between two Shapes
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.ManifoldPoint.LocalPoint">
            <summary>
            Usage depends on manifold type
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.ManifoldPoint.NormalImpulse">
            <summary>
            The non-penetration impulse
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.ManifoldPoint.TangentImpulse">
            <summary>
            The friction impulse
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.Manifold">
            <summary>
            A manifold for two touching convex Shapes.
            Box2D supports multiple types of contact:
            - Clip point versus plane with radius
            - Point versus point with radius (circles)
            The local point usage depends on the manifold type:
            - ShapeType.Circles: the local center of circleA
            - SeparationFunction.FaceA: the center of faceA
            - SeparationFunction.FaceB: the center of faceB
            Similarly the local normal usage:
            - ShapeType.Circles: not used
            - SeparationFunction.FaceA: the normal on polygonA
            - SeparationFunction.FaceB: the normal on polygonB
            We store contacts in this way so that position correction can
            account for movement, which is critical for continuous physics.
            All contact scenarios must be expressed in one of these types.
            This structure is stored across time steps, so we keep it small.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.Manifold.LocalNormal">
            <summary>
            Not use for Type.SeparationFunction.Points
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.Manifold.LocalPoint">
            <summary>
            Usage depends on manifold type
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.Manifold.PointCount">
            <summary>
            The number of manifold points
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.Manifold.Points">
            <summary>
            The points of contact
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.PointState">
            <summary>
            This is used for determining the state of contact points.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.PointState.Null">
            <summary>
            Point does not exist
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.PointState.Add">
            <summary>
            Point was added in the update
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.PointState.Persist">
            <summary>
            Point persisted across the update
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.PointState.Remove">
            <summary>
            Point was removed in the update
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.ClipVertex">
            <summary>
            Used for computing contact manifolds.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.RayCastInput">
            <summary>
            Ray-cast input data.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.RayCastInput.MaxFraction">
            <summary>
            The ray extends from p1 to p1 + maxFraction * (p2 - p1).
            If you supply a max fraction of 1, the ray extends from p1 to p2.
            A max fraction of 0.5 makes the ray go from p1 and half way to p2.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.RayCastInput.Point1">
            <summary>
            The starting point of the ray.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.RayCastInput.Point2">
            <summary>
            The ending point of the ray.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.RayCastOutput">
            <summary>
            Ray-cast output data. 
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.RayCastOutput.Fraction">
            <summary>
            The ray hits at p1 + fraction * (p2 - p1), where p1 and p2 come from RayCastInput.
            Contains the actual fraction of the ray where it has the intersection point.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.RayCastOutput.Normal">
            <summary>
            The normal of the face of the shape the ray has hit.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.AABB">
            <summary>
            An axis aligned bounding box.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.AABB.LowerBound">
            <summary>
            The lower vertex
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.AABB.UpperBound">
            <summary>
            The upper vertex
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.AABB.Center">
            <summary>
            Get the center of the AABB.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.AABB.Extents">
            <summary>
            Get the extents of the AABB (half-widths).
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.AABB.Perimeter">
            <summary>
            Get the perimeter length
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.AABB.Vertices">
            <summary>
            Gets the vertices of the AABB.
            </summary>
            <value>The corners of the AABB</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.AABB.Q1">
            <summary>
            First quadrant
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.AABB.Q2">
            <summary>
            Second quadrant
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.AABB.Q3">
            <summary>
            Third quadrant
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.AABB.Q4">
            <summary>
            Forth quadrant
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.AABB.IsValid">
            <summary>
            Verify that the bounds are sorted. And the bounds are valid numbers (not NaN).
            </summary>
            <returns>
            	<c>true</c> if this instance is valid; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.AABB.Combine(tainicom.Aether.Physics2D.Collision.AABB@)">
            <summary>
            Combine an AABB into this one.
            </summary>
            <param name="aabb">The aabb.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.AABB.Combine(tainicom.Aether.Physics2D.Collision.AABB@,tainicom.Aether.Physics2D.Collision.AABB@)">
            <summary>
            Combine two AABBs into this one.
            </summary>
            <param name="aabb1">The aabb1.</param>
            <param name="aabb2">The aabb2.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.AABB.Contains(tainicom.Aether.Physics2D.Collision.AABB@)">
            <summary>
            Does this aabb contain the provided AABB.
            </summary>
            <param name="aabb">The aabb.</param>
            <returns>
            	<c>true</c> if it contains the specified aabb; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.AABB.Contains(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Determines whether the AAABB contains the specified point.
            </summary>
            <param name="point">The point.</param>
            <returns>
            	<c>true</c> if it contains the specified point; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.AABB.TestOverlap(tainicom.Aether.Physics2D.Collision.AABB@,tainicom.Aether.Physics2D.Collision.AABB@)">
            <summary>
            Test if the two AABBs overlap.
            </summary>
            <param name="a">The first AABB.</param>
            <param name="b">The second AABB.</param>
            <returns>True if they are overlapping.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.AABB.RayCast(tainicom.Aether.Physics2D.Collision.RayCastOutput@,tainicom.Aether.Physics2D.Collision.RayCastInput@,System.Boolean)">
            <summary>
            Raycast against this AABB using the specificed points and maxfraction (found in input)
            </summary>
            <param name="output">The results of the raycast.</param>
            <param name="input">The parameters for the raycast.</param>
            <returns>True if the ray intersects the AABB</returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.EPAxis">
            <summary>
            This structure is used to keep track of the best separating axis.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.ReferenceFace">
            <summary>
            Reference face used for clipping
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.Collision">
            <summary>
            Collision methods
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Collision.TestOverlap(tainicom.Aether.Physics2D.Collision.Shapes.Shape,System.Int32,tainicom.Aether.Physics2D.Collision.Shapes.Shape,System.Int32,tainicom.Aether.Physics2D.Common.Transform@,tainicom.Aether.Physics2D.Common.Transform@)">
            <summary>
            Test overlap between the two shapes.
            </summary>
            <param name="shapeA">The first shape.</param>
            <param name="indexA">The index for the first shape.</param>
            <param name="shapeB">The second shape.</param>
            <param name="indexB">The index for the second shape.</param>
            <param name="xfA">The transform for the first shape.</param>
            <param name="xfB">The transform for the seconds shape.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Collision.CollideCircles(tainicom.Aether.Physics2D.Collision.Manifold@,tainicom.Aether.Physics2D.Collision.Shapes.CircleShape,tainicom.Aether.Physics2D.Common.Transform@,tainicom.Aether.Physics2D.Collision.Shapes.CircleShape,tainicom.Aether.Physics2D.Common.Transform@)">
            <summary>
            Compute the collision manifold between two circles.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Collision.CollidePolygonAndCircle(tainicom.Aether.Physics2D.Collision.Manifold@,tainicom.Aether.Physics2D.Collision.Shapes.PolygonShape,tainicom.Aether.Physics2D.Common.Transform@,tainicom.Aether.Physics2D.Collision.Shapes.CircleShape,tainicom.Aether.Physics2D.Common.Transform@)">
            <summary>
            Compute the collision manifold between a polygon and a circle.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="polygonA">The polygon A.</param>
            <param name="xfA">The transform of A.</param>
            <param name="circleB">The circle B.</param>
            <param name="xfB">The transform of B.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Collision.CollidePolygons(tainicom.Aether.Physics2D.Collision.Manifold@,tainicom.Aether.Physics2D.Collision.Shapes.PolygonShape,tainicom.Aether.Physics2D.Common.Transform@,tainicom.Aether.Physics2D.Collision.Shapes.PolygonShape,tainicom.Aether.Physics2D.Common.Transform@)">
            <summary>
            Compute the collision manifold between two polygons.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="polyA">The poly A.</param>
            <param name="transformA">The transform A.</param>
            <param name="polyB">The poly B.</param>
            <param name="transformB">The transform B.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Collision.CollideEdgeAndCircle(tainicom.Aether.Physics2D.Collision.Manifold@,tainicom.Aether.Physics2D.Collision.Shapes.EdgeShape,tainicom.Aether.Physics2D.Common.Transform@,tainicom.Aether.Physics2D.Collision.Shapes.CircleShape,tainicom.Aether.Physics2D.Common.Transform@)">
            <summary>
            Compute contact points for edge versus circle.
            This accounts for edge connectivity.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="edgeA">The edge A.</param>
            <param name="transformA">The transform A.</param>
            <param name="circleB">The circle B.</param>
            <param name="transformB">The transform B.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Collision.CollideEdgeAndPolygon(tainicom.Aether.Physics2D.Collision.Manifold@,tainicom.Aether.Physics2D.Collision.Shapes.EdgeShape,tainicom.Aether.Physics2D.Common.Transform@,tainicom.Aether.Physics2D.Collision.Shapes.PolygonShape,tainicom.Aether.Physics2D.Common.Transform@)">
            <summary>
            Collides and edge and a polygon, taking into account edge adjacency.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="edgeA">The edge A.</param>
            <param name="xfA">The xf A.</param>
            <param name="polygonB">The polygon B.</param>
            <param name="xfB">The xf B.</param>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.Collision.EPCollider.TempPolygon">
            <summary>
            This holds polygon B expressed in frame A.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Collision.ClipSegmentToLine(tainicom.Aether.Physics2D.Common.FixedArray2{tainicom.Aether.Physics2D.Collision.ClipVertex}@,tainicom.Aether.Physics2D.Common.FixedArray2{tainicom.Aether.Physics2D.Collision.ClipVertex}@,Microsoft.Xna.Framework.Vector2,System.Single,System.Int32)">
            <summary>
            Clipping for contact manifolds.
            </summary>
            <param name="vOut">The v out.</param>
            <param name="vIn">The v in.</param>
            <param name="normal">The normal.</param>
            <param name="offset">The offset.</param>
            <param name="vertexIndexA">The vertex index A.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Collision.EdgeSeparation(tainicom.Aether.Physics2D.Collision.Shapes.PolygonShape,tainicom.Aether.Physics2D.Common.Transform@,System.Int32,tainicom.Aether.Physics2D.Collision.Shapes.PolygonShape)">
            <summary>
            Find the separation between poly1 and poly2 for a give edge normal on poly1.
            </summary>
            <param name="poly1">The poly1.</param>
            <param name="xf1">The XF1.</param>
            <param name="edge1">The edge1.</param>
            <param name="poly2">The poly2.</param>
            <param name="xf2">The XF2.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Collision.FindMaxSeparation(System.Int32@,tainicom.Aether.Physics2D.Collision.Shapes.PolygonShape,tainicom.Aether.Physics2D.Common.Transform@,tainicom.Aether.Physics2D.Collision.Shapes.PolygonShape,tainicom.Aether.Physics2D.Common.Transform@)">
            <summary>
            Find the max separation between poly1 and poly2 using edge normals from poly1.
            </summary>
            <param name="edgeIndex">Index of the edge.</param>
            <param name="poly1">The poly1.</param>
            <param name="xf1">The XF1.</param>
            <param name="poly2">The poly2.</param>
            <param name="xf2">The XF2.</param>
            <returns></returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.DistanceProxy">
            <summary>
            A distance proxy is used by the GJK algorithm.
            It encapsulates any shape.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DistanceProxy.#ctor(tainicom.Aether.Physics2D.Collision.Shapes.Shape,System.Int32)">
            <summary>
            Initialize the proxy using the given shape. The shape
            must remain in scope while the proxy is in use.
            </summary>
            <param name="shape">The shape.</param>
            <param name="index">The index.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DistanceProxy.GetSupport(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Get the supporting vertex index in the given direction.
            </summary>
            <param name="direction">The direction.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DistanceProxy.GetSupportVertex(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Get the supporting vertex in the given direction.
            </summary>
            <param name="direction">The direction.</param>
            <returns></returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.SimplexCache">
            <summary>
            Used to warm start ComputeDistance.
            Set count to zero on first call.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.SimplexCache.Count">
            <summary>
            Length or area
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.SimplexCache.IndexA">
            <summary>
            Vertices on shape A
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.SimplexCache.IndexB">
            <summary>
            Vertices on shape B
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.DistanceInput">
            <summary>
            Input for Distance.ComputeDistance().
            You have to option to use the shape radii in the computation. 
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.DistanceOutput">
            <summary>
            Output for Distance.ComputeDistance().
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.DistanceOutput.Iterations">
            <summary>
            Number of GJK iterations used
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.DistanceOutput.PointA">
            <summary>
            Closest point on shapeA
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.DistanceOutput.PointB">
            <summary>
            Closest point on shapeB
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.SimplexVertex.A">
            <summary>
            Barycentric coordinate for closest point 
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.SimplexVertex.IndexA">
            <summary>
            wA index
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.SimplexVertex.IndexB">
            <summary>
            wB index
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.SimplexVertex.W">
            <summary>
            wB - wA
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.SimplexVertex.WA">
            <summary>
            Support point in proxyA
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.SimplexVertex.WB">
            <summary>
            Support point in proxyB
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.Distance">
            <summary>
            The Gilbert–Johnson–Keerthi distance algorithm that provides the distance between shapes.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.Distance.GJKCalls">
            <summary>
            The number of calls made to the ComputeDistance() function.
            Note: This is only activated when Settings.EnableDiagnostics = true
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.Distance.GJKIters">
            <summary>
            The number of iterations that was made on the last call to ComputeDistance().
            Note: This is only activated when Settings.EnableDiagnostics = true
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.Distance.GJKMaxIters">
            <summary>
            The maximum numer of iterations ever mae with calls to the CompteDistance() funtion.
            Note: This is only activated when Settings.EnableDiagnostics = true
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.TreeNode`1">
            <summary>
            A node in the dynamic tree. The client does not interact with this directly.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.TreeNode`1.AABB">
            <summary>
            Enlarged AABB
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.TreeNode`1.Next">
            <summary>
            Next free node
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.DynamicTree`1">
             <summary>
             A dynamic tree arranges data in a binary tree to accelerate
             queries such as volume queries and ray casts. Leafs are proxies
             with an AABB. In the tree we expand the proxy AABB by Settings.b2_fatAABBFactor
             so that the proxy AABB is bigger than the client object. This allows the client
             object to move by small amounts without triggering a tree update.
            
             Nodes are pooled and relocatable, so we use node indices rather than pointers.
             </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTree`1.#ctor">
            <summary>
            Constructing the tree initializes the node pool.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.DynamicTree`1.Height">
            <summary>
            Compute the height of the binary tree in O(N) time. Should not be called often.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.DynamicTree`1.AreaRatio">
            <summary>
            Get the ratio of the sum of the node areas to the root area.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.DynamicTree`1.MaxBalance">
            <summary>
            Get the maximum balance of an node in the tree. The balance is the difference
            in height of the two children of a node.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTree`1.AddProxy(tainicom.Aether.Physics2D.Collision.AABB@)">
            <summary>
            Create a proxy in the tree as a leaf node. We return the index
            of the node instead of a pointer so that we can grow
            the node pool.        
            /// </summary>
            <param name="aabb">The aabb.</param>
            <param name="userData">The user data.</param>
            <returns>Index of the created proxy</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTree`1.RemoveProxy(System.Int32)">
            <summary>
            Destroy a proxy. This asserts if the id is invalid.
            </summary>
            <param name="proxyId">The proxy id.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTree`1.MoveProxy(System.Int32,tainicom.Aether.Physics2D.Collision.AABB@,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Move a proxy with a swepted AABB. If the proxy has moved outside of its fattened AABB,
            then the proxy is removed from the tree and re-inserted. Otherwise
            the function returns immediately.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <param name="aabb">The aabb.</param>
            <param name="displacement">The displacement.</param>
            <returns>true if the proxy was re-inserted.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTree`1.SetUserData(System.Int32,`0)">
            <summary>
            Set proxy user data.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="proxyId">The proxy id.</param>
            <param name="userData">The proxy user data.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTree`1.GetUserData(System.Int32)">
            <summary>
            Get proxy user data.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="proxyId">The proxy id.</param>
            <returns>the proxy user data or 0 if the id is invalid.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTree`1.GetFatAABB(System.Int32,tainicom.Aether.Physics2D.Collision.AABB@)">
            <summary>
            Get the fat AABB for a proxy.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <param name="fatAABB">The fat AABB.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTree`1.GetFatAABB(System.Int32)">
            <summary>
            Get the fat AABB for a proxy.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <returns>The fat AABB.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTree`1.TestFatAABBOverlap(System.Int32,System.Int32)">
            <summary>
            Test overlap of fat AABBs.
            </summary>
            <param name="proxyIdA">The proxy id A.</param>
            <param name="proxyIdB">The proxy id B.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTree`1.Query(tainicom.Aether.Physics2D.Collision.BroadPhaseQueryCallback,tainicom.Aether.Physics2D.Collision.AABB@)">
            <summary>
            Query an AABB for overlapping proxies. The callback class
            is called for each proxy that overlaps the supplied AABB.
            </summary>
            <param name="callback">The callback.</param>
            <param name="aabb">The aabb.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTree`1.RayCast(tainicom.Aether.Physics2D.Collision.BroadPhaseRayCastCallback,tainicom.Aether.Physics2D.Collision.RayCastInput@)">
            <summary>
            Ray-cast against the proxies in the tree. This relies on the callback
            to perform a exact ray-cast in the case were the proxy contains a Shape.
            The callback also performs the any collision filtering. This has performance
            roughly equal to k * log(n), where k is the number of collisions and n is the
            number of proxies in the tree.
            </summary>
            <param name="callback">A callback class that is called for each proxy that is hit by the ray.</param>
            <param name="input">The ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTree`1.Balance(System.Int32)">
            <summary>
            Perform a left or right rotation if node N is imbalanced.
            </summary>
            <param name="iN"></param>
            <returns>the new root index.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTree`1.ComputeHeight(System.Int32)">
            <summary>
            Compute the height of a sub-tree.
            </summary>
            <param name="nodeId">The node id to use as parent.</param>
            <returns>The height of the tree.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTree`1.ComputeHeight">
            <summary>
            Compute the height of the entire tree.
            </summary>
            <returns>The height of the tree.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTree`1.Validate">
            <summary>
            Validate this tree. For testing.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTree`1.RebuildBottomUp">
            <summary>
            Build an optimal tree. Very expensive. For testing.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTree`1.ShiftOrigin(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Shift the origin of the nodes
            </summary>
            <param name="newOrigin">The displacement to use.</param>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.DynamicTreeBroadPhase">
            <summary>
            The broad-phase is used for computing pairs and performing volume queries and ray casts.
            This broad-phase does not persist pairs. Instead, this reports potentially new pairs.
            It is up to the client to consume the new pairs and to track subsequent overlap.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.DynamicTreeBroadPhase`1">
            <summary>
            The broad-phase is used for computing pairs and performing volume queries and ray casts.
            This broad-phase does not persist pairs. Instead, this reports potentially new pairs.
            It is up to the client to consume the new pairs and to track subsequent overlap.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTreeBroadPhase`1.#ctor">
            <summary>
            Constructs a new broad phase based on the dynamic tree implementation
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.DynamicTreeBroadPhase`1.ProxyCount">
            <summary>
            Get the number of proxies.
            </summary>
            <value>The proxy count.</value>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTreeBroadPhase`1.AddProxy(tainicom.Aether.Physics2D.Collision.AABB@)">
            <summary>
            Create a proxy with an initial AABB. Pairs are not reported until
            UpdatePairs is called.
            </summary>
            <param name="proxy">The user data.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTreeBroadPhase`1.RemoveProxy(System.Int32)">
            <summary>
            Destroy a proxy. It is up to the client to remove any pairs.
            </summary>
            <param name="proxyId">The proxy id.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTreeBroadPhase`1.QueryCallback(System.Int32)">
            <summary>
            This is called from DynamicTree.Query when we are gathering pairs.
            </summary>
            <param name="proxyId"></param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTreeBroadPhase`1.GetFatAABB(System.Int32,tainicom.Aether.Physics2D.Collision.AABB@)">
            <summary>
            Get the AABB for a proxy.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <param name="aabb">The aabb.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTreeBroadPhase`1.GetProxy(System.Int32)">
            <summary>
            Get user data from a proxy. Returns null if the id is invalid.
            </summary>
            <param name="proxyId">The proxy id.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTreeBroadPhase`1.TestOverlap(System.Int32,System.Int32)">
            <summary>
            Test overlap of fat AABBs.
            </summary>
            <param name="proxyIdA">The proxy id A.</param>
            <param name="proxyIdB">The proxy id B.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTreeBroadPhase`1.UpdatePairs(tainicom.Aether.Physics2D.Collision.BroadphaseDelegate)">
            <summary>
            Update the pairs. This results in pair callbacks. This can only add pairs.
            </summary>
            <param name="callback">The callback.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTreeBroadPhase`1.Query(tainicom.Aether.Physics2D.Collision.BroadPhaseQueryCallback,tainicom.Aether.Physics2D.Collision.AABB@)">
            <summary>
            Query an AABB for overlapping proxies. The callback class
            is called for each proxy that overlaps the supplied AABB.
            </summary>
            <param name="callback">The callback.</param>
            <param name="aabb">The aabb.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.DynamicTreeBroadPhase`1.RayCast(tainicom.Aether.Physics2D.Collision.BroadPhaseRayCastCallback,tainicom.Aether.Physics2D.Collision.RayCastInput@)">
            <summary>
            Ray-cast against the proxies in the tree. This relies on the callback
            to perform a exact ray-cast in the case were the proxy contains a shape.
            The callback also performs the any collision filtering. This has performance
            roughly equal to k * log(n), where k is the number of collisions and n is the
            number of proxies in the tree.
            </summary>
            <param name="callback">A callback class that is called for each proxy that is hit by the ray.</param>
            <param name="input">The ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.DynamicTreeBroadPhase`1.TreeQuality">
            <summary>
            Get the tree quality based on the area of the tree.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.DynamicTreeBroadPhase`1.TreeBalance">
            <summary>
            Gets the balance of the tree.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.DynamicTreeBroadPhase`1.TreeHeight">
            <summary>
            Gets the height of the tree.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.Shapes.ChainShape">
            <summary>
            A chain shape is a free form sequence of line segments.
            The chain has two-sided collision, so you can use inside and outside collision.
            Therefore, you may use any winding order.
            Connectivity information is used to create smooth collisions.
            WARNING: The chain will not collide properly if there are self-intersections.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.Shapes.ChainShape.Vertices">
            <summary>
            The vertices. These are not owned/freed by the chain Shape.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.ChainShape.#ctor">
            <summary>
            Constructor for ChainShape. By default have 0 in density.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.ChainShape.#ctor(tainicom.Aether.Physics2D.Common.Vertices,System.Boolean)">
            <summary>
            Create a new chainshape from the vertices.
            </summary>
            <param name="vertices">The vertices to use. Must contain 2 or more vertices.</param>
            <param name="createLoop">Set to true to create a closed loop. It connects the first vertice to the last, and automatically adjusts connectivity to create smooth collisions along the chain.</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.Shapes.ChainShape.PrevVertex">
            <summary>
            Establish connectivity to a vertex that precedes the first vertex.
            Don't call this for loops.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.Shapes.ChainShape.NextVertex">
            <summary>
            Establish connectivity to a vertex that follows the last vertex.
            Don't call this for loops.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.ChainShape.GetChildEdge(tainicom.Aether.Physics2D.Collision.Shapes.EdgeShape,System.Int32)">
            <summary>
            This method has been optimized to reduce garbage.
            </summary>
            <param name="edge">The cached edge to set properties on.</param>
            <param name="index">The index.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.ChainShape.GetChildEdge(System.Int32)">
            <summary>
            Get a child edge.
            </summary>
            <param name="index">The index.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.ChainShape.CompareTo(tainicom.Aether.Physics2D.Collision.Shapes.ChainShape)">
            <summary>
            Compare the chain to another chain
            </summary>
            <param name="shape">The other chain</param>
            <returns>True if the two chain shapes are the same</returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.Shapes.CircleShape">
            <summary>
            A circle shape.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.CircleShape.#ctor(System.Single,System.Single)">
            <summary>
            Create a new circle with the desired radius and density.
            </summary>
            <param name="radius">The radius of the circle.</param>
            <param name="density">The density of the circle.</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.Shapes.CircleShape.Position">
            <summary>
            Get or set the position of the circle
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.CircleShape.CompareTo(tainicom.Aether.Physics2D.Collision.Shapes.CircleShape)">
            <summary>
            Compare the circle to another circle
            </summary>
            <param name="shape">The other circle</param>
            <returns>True if the two circles are the same size and have the same position</returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.Shapes.EdgeShape">
            <summary>
            A line segment (edge) shape. These can be connected in chains or loops
            to other edge shapes.
            The connectivity information is used to ensure correct contact normals.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.Shapes.EdgeShape._vertex1">
            <summary>
            Edge start vertex
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.Shapes.EdgeShape._vertex2">
            <summary>
            Edge end vertex
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.EdgeShape.#ctor(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Create a new EdgeShape with the specified start and end.
            </summary>
            <param name="start">The start of the edge.</param>
            <param name="end">The end of the edge.</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.Shapes.EdgeShape.HasVertex0">
            <summary>
            Is true if the edge is connected to an adjacent vertex before vertex 1.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.Shapes.EdgeShape.HasVertex3">
            <summary>
            Is true if the edge is connected to an adjacent vertex after vertex2.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.Shapes.EdgeShape.Vertex0">
            <summary>
            Optional adjacent vertices. These are used for smooth collision.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.Shapes.EdgeShape.Vertex3">
            <summary>
            Optional adjacent vertices. These are used for smooth collision.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.Shapes.EdgeShape.Vertex1">
            <summary>
            These are the edge vertices
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.Shapes.EdgeShape.Vertex2">
            <summary>
            These are the edge vertices
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.EdgeShape.Set(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Set this as an isolated edge.
            </summary>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.Shapes.PolygonShape">
            <summary>
            Represents a simple non-selfintersecting convex polygon.
            Create a convex hull from the given array of points.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.PolygonShape.#ctor(tainicom.Aether.Physics2D.Common.Vertices,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:tainicom.Aether.Physics2D.Collision.Shapes.PolygonShape"/> class.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="density">The density.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.PolygonShape.#ctor(System.Single)">
            <summary>
            Create a new PolygonShape with the specified density.
            </summary>
            <param name="density">The density.</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.Shapes.PolygonShape.Vertices">
            <summary>
            Create a convex hull from the given array of local points.
            The number of vertices must be in the range [3, Settings.MaxPolygonVertices].
            Warning: the points may be re-ordered, even if they form a convex polygon
            Warning: collinear points are handled but not removed. Collinear points may lead to poor stacking behavior.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.PolygonShape.ComputeAABB(tainicom.Aether.Physics2D.Collision.AABB@,tainicom.Aether.Physics2D.Common.Transform@,System.Int32)">
            <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
            <param name="aabb">The aabb results.</param>
            <param name="transform">The world transform of the shape.</param>
            <param name="childIndex">The child shape index.</param>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.Shapes.MassData">
            <summary>
            This holds the mass data computed for a shape.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.Shapes.MassData.Area">
            <summary>
            The area of the shape
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.Shapes.MassData.Centroid">
            <summary>
            The position of the shape's centroid relative to the shape's origin.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.Shapes.MassData.Inertia">
            <summary>
            The rotational inertia of the shape about the local origin.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.Shapes.MassData.Mass">
            <summary>
            The mass of the shape, usually in kilograms.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.MassData.op_Equality(tainicom.Aether.Physics2D.Collision.Shapes.MassData,tainicom.Aether.Physics2D.Collision.Shapes.MassData)">
            <summary>
            The equal operator
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.MassData.op_Inequality(tainicom.Aether.Physics2D.Collision.Shapes.MassData,tainicom.Aether.Physics2D.Collision.Shapes.MassData)">
            <summary>
            The not equal operator
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.Shapes.Shape">
            <summary>
            A shape is used for collision detection. You can create a shape however you like.
            Shapes used for simulation in World are created automatically when a Fixture
            is created. Shapes may encapsulate a one or more child shapes.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Collision.Shapes.Shape.MassData">
            <summary>
            Contains the properties of the shape such as:
            - Area of the shape
            - Centroid
            - Inertia
            - Mass
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.Shapes.Shape.ShapeType">
            <summary>
            Get the type of this shape.
            </summary>
            <value>The type of the shape.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.Shapes.Shape.ChildCount">
            <summary>
            Get the number of child primitives.
            </summary>
            <value></value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.Shapes.Shape.Density">
            <summary>
            Gets or sets the density.
            Changing the density causes a recalculation of shape properties.
            </summary>
            <value>The density.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Collision.Shapes.Shape.Radius">
            <summary>
            Radius of the Shape
            Changing the radius causes a recalculation of shape properties.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.Shape.Clone">
            <summary>
            Clone the concrete shape
            </summary>
            <returns>A clone of the shape</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.Shape.TestPoint(tainicom.Aether.Physics2D.Common.Transform@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Test a point for containment in this shape.
            Note: This only works for convex shapes.
            </summary>
            <param name="transform">The shape world transform.</param>
            <param name="point">A point in world coordinates.</param>
            <returns>True if the point is inside the shape</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.Shape.RayCast(tainicom.Aether.Physics2D.Collision.RayCastOutput@,tainicom.Aether.Physics2D.Collision.RayCastInput@,tainicom.Aether.Physics2D.Common.Transform@,System.Int32)">
            <summary>
            Cast a ray against a child shape.
            </summary>
            <param name="output">The ray-cast results.</param>
            <param name="input">The ray-cast input parameters.</param>
            <param name="transform">The transform to be applied to the shape.</param>
            <param name="childIndex">The child shape index.</param>
            <returns>True if the ray-cast hits the shape</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.Shape.ComputeAABB(tainicom.Aether.Physics2D.Collision.AABB@,tainicom.Aether.Physics2D.Common.Transform@,System.Int32)">
            <summary>
            Given a transform, compute the associated axis aligned bounding box for a child shape.
            </summary>
            <param name="aabb">The aabb results.</param>
            <param name="transform">The world transform of the shape.</param>
            <param name="childIndex">The child shape index.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.Shape.ComputeProperties">
            <summary>
            Compute the mass properties of this shape using its dimensions and density.
            The inertia tensor is computed about the local origin, not the centroid.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.Shapes.Shape.ComputeSubmergedArea(Microsoft.Xna.Framework.Vector2@,System.Single,tainicom.Aether.Physics2D.Common.Transform@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Used for the buoyancy controller
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Collision.TOIInput">
            <summary>
            Input parameters for CalculateTimeOfImpact
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Collision.TimeOfImpact.CalculateTimeOfImpact(tainicom.Aether.Physics2D.Collision.TOIOutput@,tainicom.Aether.Physics2D.Collision.TOIInput@)">
            <summary>
            Compute the upper bound on time before two shapes penetrate. Time is represented as
            a fraction between [0,tMax]. This uses a swept separating axis and may miss some intermediate,
            non-tunneling collision. If you change the time interval, you should call this function
            again.
            Note: use Distance() to compute the contact point and normal at the time of impact.
            </summary>
            <param name="output">The output.</param>
            <param name="input">The input.</param>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.ConvexHull.ChainHull">
            <summary>
            Andrew's Monotone Chain Convex Hull algorithm.
            Used to get the convex hull of a point cloud.
            
            Source: http://www.softsurfer.com/Archive/algorithm_0109/algorithm_0109.htm
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.ConvexHull.ChainHull.GetConvexHull(tainicom.Aether.Physics2D.Common.Vertices)">
            <summary>
            Returns the convex hull from the given vertices..
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.ConvexHull.GiftWrap">
            <summary>
            Giftwrap convex hull algorithm.
            O(nh) time complexity, where n is the number of points and h is the number of points on the convex hull.
            
            See http://en.wikipedia.org/wiki/Gift_wrapping_algorithm for more details.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.ConvexHull.GiftWrap.GetConvexHull(tainicom.Aether.Physics2D.Common.Vertices)">
            <summary>
            Returns the convex hull from the given vertices.
            </summary>
            <param name="vertices">The vertices.</param>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.ConvexHull.Melkman">
            <summary>
            Creates a convex hull.
            Note:
            1. Vertices must be of a simple polygon, i.e. edges do not overlap.
            2. Melkman does not work on point clouds
            </summary>
            <remarks>
            Implemented using Melkman's Convex Hull Algorithm - O(n) time complexity.
            Reference: http://www.ams.sunysb.edu/~jsbm/courses/345/melkman.pdf
            </remarks>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.ConvexHull.Melkman.GetConvexHull(tainicom.Aether.Physics2D.Common.Vertices)">
            <summary>
            Returns a convex hull from the given vertices.
            </summary>
            <returns>A convex hull in counter clockwise winding order.</returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.Decomposition.BayazitDecomposer">
            <summary>
            Convex decomposition algorithm created by Mark Bayazit (http://mnbayazit.com/)
            
            Properties:
            - Tries to decompose using polygons instead of triangles.
            - Tends to produce optimal results with low processing time.
            - Running time is O(nr), n = number of vertices, r = reflex vertices.
            - Does not support holes.
            
            For more information about this algorithm, see http://mnbayazit.com/406/bayazit
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.BayazitDecomposer.ConvexPartition(tainicom.Aether.Physics2D.Common.Vertices)">
            <summary>
            Decompose the polygon into several smaller non-concave polygon.
            If the polygon is already convex, it will return the original polygon, unless it is over Settings.MaxPolygonVertices.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.Decomposition.CDTDecomposer">
            <summary>
            2D constrained Delaunay triangulation algorithm.
            Based on the paper "Sweep-line algorithm for constrained Delaunay triangulation" by V. Domiter and and B. Zalik
            
            Properties:
            - Creates triangles with a large interior angle.
            - Supports holes
            - Generate a lot of garbage due to incapsulation of the Poly2Tri library.
            - Running time is O(n^2), n = number of vertices.
            - Does not care about winding order.
            
            Source: http://code.google.com/p/poly2tri/
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDTDecomposer.ConvexPartition(tainicom.Aether.Physics2D.Common.Vertices)">
            <summary>
            Decompose the polygon into several smaller non-concave polygon.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.EdgeIsConstrained">
            Neighbor pointers 
            Flags to determine if an edge is a Delauney edge 
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.EdgeIsDelaunay">
            Flags to determine if an edge is a Constrained edge 
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.Points">
            Has this triangle been marked as an interior triangle? 
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.MarkNeighbor(tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle)">
            <summary>
            Update neighbor pointers
            </summary>
            <param name="p1">Point 1 of the shared edge</param>
            <param name="p2">Point 2 of the shared edge</param>
            <param name="t">This triangle's new neighbor</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.MarkNeighbor(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle)">
            <summary>
            Exhaustive search to update neighbor pointers
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.Clear">
            Clears all references to all other triangles and points
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.OppositePoint(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint)">
            <param name="t">Opposite triangle</param>
            <param name="p">The point in t that isn't shared between the triangles</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.Legalize(tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            Legalize triangle by rotating clockwise around oPoint
            </summary>
            <param name="oPoint">The origin point to rotate around</param>
            <param name="nPoint">???</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.MarkNeighborEdges">
            <summary>
            Finalize edge marking
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.MarkConstrainedEdge(tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            Mark edge as constrained
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle.EdgeIndex(tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            Get the index of the neighbor that shares this edge (or -1 if it isn't shared)
            </summary>
            <returns>index of the shared edge or -1 if edge isn't shared</returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFront">
            @author Thomas Åhlen (thahlen@gmail.com)
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFront.FindSearchNode(System.Double)">
            <summary>
            MM:  This seems to be used by LocateNode to guess a position in the implicit linked list of AdvancingFrontNodes near x
                 Removed an overload that depended on this being exact
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFront.LocateNode(tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            We use a balancing tree to locate a node smaller or equal to given key value
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFront.LocatePoint(tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            This implementation will use simple node traversal algorithm to find a point on the front
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.Triangulate(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext)">
            <summary>
            Triangulate simple polygon with holes
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.Sweep(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext)">
            <summary>
            Start sweeping the Y-sorted point set from bottom to top
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.FinalizationConvexHull(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext)">
            <summary>
            If this is a Delaunay Triangulation of a pointset we need to fill so the triangle mesh gets a ConvexHull 
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.TurnAdvancingFrontConvex(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFrontNode,tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            We will traverse the entire advancing front and fill it to form a convex hull.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.PointEvent(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            Find closes node to the left of the new point and
            create a new triangle. If needed new holes and basins
            will be filled to.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.NewFrontTriangle(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            Creates a new front triangle and legalize it
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.NextFlipPoint(tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            When we need to traverse from one triangle to the next we need 
            the point in current triangle that is the opposite point to the next
            triangle. 
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.NextFlipTriangle(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,tainicom.Aether.Physics2D.Common.Decomposition.CDT.Orientation,tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle,tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            After a flip we have two triangles and know that only one will still be
            intersecting the edge. So decide which to contiune with and legalize the other
            </summary>
            <param name="tcx"></param>
            <param name="o">should be the result of an TriangulationUtil.orient2d( eq, op, ep )</param>
            <param name="t">triangle 1</param>
            <param name="ot">triangle 2</param>
            <param name="p">a point shared by both triangles</param>
            <param name="op">another point shared by both triangles</param>
            <returns>returns the triangle still intersecting the edge</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.FlipScanEdgeEvent(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle,tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint)" -->
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.FillAdvancingFront(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            Fills holes in the Advancing Front
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.FillBasin(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            Fills a basin that has formed on the Advancing Front to the right
            of given node.
            First we decide a left,bottom and right node that forms the 
            boundaries of the basin. Then we do a reqursive fill.
            </summary>
            <param name="tcx"></param>
            <param name="node">starting node, this or next node will be left node</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.FillBasinReq(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            Recursive algorithm to fill a Basin with triangles
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.HoleAngle(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            ???
            </summary>
            <param name="node">middle node</param>
            <returns>the angle between 3 front nodes</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.BasinAngle(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            The basin angle is decided against the horizontal line [1,0]
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.Fill(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.AdvancingFrontNode)">
            <summary>
            Adds a triangle to the advancing front to fill a hole.
            </summary>
            <param name="tcx"></param>
            <param name="node">middle node, that is the bottom of the hole</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.Legalize(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext,tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle)">
            <summary>
            Returns true if triangle was legalized
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweep.RotateTrianglePair(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            Rotates a triangle pair one vertex CW
                  n2                    n2
             P +-----+             P +-----+
               | t  /|               |\  t |  
               |   / |               | \   |
             n1|  /  |n3           n1|  \  |n3
               | /   |    after CW   |   \ |
               |/ oT |               | oT \|
               +-----+ oP            +-----+
                  n4                    n4
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepConstraint.#ctor(tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
            Give two points in any order. Will always be ordered so
            that q.y > p.y and q.x > p.x if same y value 
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext">
             
             @author Thomas Åhlén, thahlen@gmail.com
            
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.Sweep.DTSweepContext.MapTriangleToNodes(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Delaunay.DelaunayTriangle)">
            <summary>
            Try to map a node to all sides of this triangle that don't have 
            a neighbor.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Polygon.Polygon.#ctor(System.Collections.Generic.IList{tainicom.Aether.Physics2D.Common.Decomposition.CDT.Polygon.PolygonPoint})">
            <summary>
            Create a polygon from a list of at least 3 points with no duplicates.
            </summary>
            <param name="points">A list of unique points</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Polygon.Polygon.#ctor(System.Collections.Generic.IEnumerable{tainicom.Aether.Physics2D.Common.Decomposition.CDT.Polygon.PolygonPoint})">
            <summary>
            Create a polygon from a list of at least 3 points with no duplicates.
            </summary>
            <param name="points">A list of unique points.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Polygon.Polygon.PrepareTriangulation(tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationContext)">
            <summary>
            Creates constraints and populates the context with points
            </summary>
            <param name="tcx">The context</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Polygon.Polygon.AddHole(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Polygon.Polygon)">
            <summary>
            Add a hole to the polygon.
            </summary>
            <param name="poly">A subtraction polygon fully contained inside this polygon.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Polygon.Polygon.InsertPointAfter(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Polygon.PolygonPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.Polygon.PolygonPoint)">
            <summary>
            Inserts newPoint after point.
            </summary>
            <param name="point">The point to insert after in the polygon</param>
            <param name="newPoint">The point to insert into the polygon</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Polygon.Polygon.AddPoints(System.Collections.Generic.IEnumerable{tainicom.Aether.Physics2D.Common.Decomposition.CDT.Polygon.PolygonPoint})">
            <summary>
            Inserts list (after last point in polygon?)
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Polygon.Polygon.AddPoint(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Polygon.PolygonPoint)">
            <summary>
            Adds a point after the last in the polygon.
            </summary>
            <param name="p">The point to add</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Polygon.Polygon.RemovePoint(tainicom.Aether.Physics2D.Common.Decomposition.CDT.Polygon.PolygonPoint)">
            <summary>
            Removes a point from the polygon.
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Sets.ConstrainedPointSet.#ctor(System.Collections.Generic.List{tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint},System.Collections.Generic.IEnumerable{tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint})">
            
            @param points - A list of all points in PointSet
            @param constraints - Pairs of two points defining a constraint, all points <b>must</b> be part of given PointSet!
        </member>
        <!-- Badly formed XML comment ignored for member "M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.Sets.ConstrainedPointSet.isValid" -->
        <member name="T:tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationUtil">
            @author Thomas Åhlén, thahlen@gmail.com
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationUtil.SmartIncircle(tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint)">
            <summary>
              Requirements:
            1. a,b and c form a triangle.
            2. a and d is know to be on opposite side of bc
            <code>
                           a
                           +
                          / \
                         /   \
                       b/     \c
                       +-------+ 
                      /    B    \  
                     /           \ 
            </code>
               Facts:
             d has to be in area B to have a chance to be inside the circle formed by a,b and c
             d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW
             This preknowledge gives us a way to optimize the incircle test
            </summary>
            <param name="pa">triangle point, opposite d</param>
            <param name="pb">triangle point</param>
            <param name="pc">triangle point</param>
            <param name="pd">point opposite a</param>
            <returns>true if d is inside circle, false if on circle edge</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationUtil.Orient2d(tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint,tainicom.Aether.Physics2D.Common.Decomposition.CDT.TriangulationPoint)">
            Forumla to calculate signed area
            Positive if CCW
            Negative if CW
            0 if collinear
            A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
                         =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.Decomposition.EarclipDecomposer">
            <summary>
            Convex decomposition algorithm using ear clipping
            
            Properties:
            - Only works on simple polygons.
            - Does not support holes.
            - Running time is O(n^2), n = number of vertices.
            
            Source: http://www.ewjordan.com/earClip/
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.EarclipDecomposer.ConvexPartition(tainicom.Aether.Physics2D.Common.Vertices,System.Single)">
            <summary>
            Decompose the polygon into several smaller non-concave polygon.
            Each resulting polygon will have no more than Settings.MaxPolygonVertices vertices.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="tolerance">The tolerance.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.EarclipDecomposer.TriangulatePolygon(tainicom.Aether.Physics2D.Common.Vertices,System.Single)">
             <summary>
             Triangulates a polygon using simple ear-clipping algorithm. Returns
             size of Triangle array unless the polygon can't be triangulated.
             This should only happen if the polygon self-intersects,
             though it will not _always_ return null for a bad polygon - it is the
             caller's responsibility to check for self-intersection, and if it
             doesn't, it should at least check that the return value is non-null
             before using. You're warned!
            
             Triangles may be degenerate, especially if you have identical points
             in the input to the algorithm.  Check this before you use them.
            
             This is totally unoptimized, so for large polygons it should not be part
             of the simulation loop.
             </summary>
             <remarks>
             Only works on simple polygons.
             </remarks>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.EarclipDecomposer.ResolvePinchPoint(tainicom.Aether.Physics2D.Common.Vertices,tainicom.Aether.Physics2D.Common.Vertices@,tainicom.Aether.Physics2D.Common.Vertices@,System.Single)">
            <summary>
            Finds and fixes "pinch points," points where two polygon
            vertices are at the same point.
            
            If a pinch point is found, pin is broken up into poutA and poutB
            and true is returned; otherwise, returns false.
            
            Mostly for internal use.
            
            O(N^2) time, which sucks...
            </summary>
            <param name="pin">The pin.</param>
            <param name="poutA">The pout A.</param>
            <param name="poutB">The pout B.</param>
            <param name="tolerance"></param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.EarclipDecomposer.Remainder(System.Int32,System.Int32)">
            <summary>
            Fix for obnoxious behavior for the % operator for negative numbers...
            </summary>
            <param name="x">The x.</param>
            <param name="modulus">The modulus.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.EarclipDecomposer.IsEar(System.Int32,System.Single[],System.Single[],System.Int32)">
            <summary>
            Checks if vertex i is the tip of an ear in polygon defined by xv[] and  yv[].
            </summary>
            <param name="i">The i.</param>
            <param name="xv">The xv.</param>
            <param name="yv">The yv.</param>
            <param name="xvLength">Length of the xv.</param>
            <remarks>
            Assumes clockwise orientation of polygon.
            </remarks>
            <returns>
            	<c>true</c> if the specified i is ear; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.Decomposition.FlipcodeDecomposer">
            <summary>
            Convex decomposition algorithm created by unknown
            
            Properties:
            - No support for holes
            - Very fast
            - Only works on simple polygons
            - Only works on counter clockwise polygons
            
            More information: http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.FlipcodeDecomposer.ConvexPartition(tainicom.Aether.Physics2D.Common.Vertices)">
            <summary>
            Decompose the polygon into triangles.
            
            Properties:
            - Only works on counter clockwise polygons
            
            </summary>
            <param name="vertices">The list of points describing the polygon</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.FlipcodeDecomposer.InsideTriangle(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Check if the point P is inside the triangle defined by
            the points A, B, C
            </summary>
            <param name="a">The A point.</param>
            <param name="b">The B point.</param>
            <param name="c">The C point.</param>
            <param name="p">The point to be tested.</param>
            <returns>True if the point is inside the triangle</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.FlipcodeDecomposer.Snip(tainicom.Aether.Physics2D.Common.Vertices,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32[])">
            <summary>
            Cut a the contour and add a triangle into V to describe the 
            location of the cut
            </summary>
            <param name="contour">The list of points defining the polygon</param>
            <param name="u">The index of the first point</param>
            <param name="v">The index of the second point</param>
            <param name="w">The index of the third point</param>
            <param name="n">The number of elements in the array.</param>
            <param name="V">The array to populate with indicies of triangles.</param>
            <returns>True if a triangle was found</returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.Decomposition.SeidelDecomposer">
            <summary>
            Convex decomposition algorithm created by Raimund Seidel
            
            Properties:
            - Decompose the polygon into trapezoids, then triangulate.
            - To use the trapezoid data, use ConvexPartitionTrapezoid()
            - Generate a lot of garbage due to incapsulation of the Poly2Tri library.
            - Running time is O(n log n), n = number of vertices.
            - Running time is almost linear for most simple polygons.
            - Does not care about winding order. 
            
            For more information, see Raimund Seidel's paper "A simple and fast incremental randomized
            algorithm for computing trapezoidal decompositions and for triangulating polygons"
            
            See also: "Computational Geometry", 3rd edition, by Mark de Berg et al, Chapter 6.2
                      "Computational Geometry in C", 2nd edition, by Joseph O'Rourke
            
            Original code from the Poly2Tri project by Mason Green.
            http://code.google.com/p/poly2tri/source/browse?repo=archive#hg/scala/src/org/poly2tri/seidel
            
            This implementation is from Dec 14, 2010
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.SeidelDecomposer.ConvexPartition(tainicom.Aether.Physics2D.Common.Vertices,System.Single)">
            <summary>
            Decompose the polygon into several smaller non-concave polygons.
            </summary>
            <param name="vertices">The polygon to decompose.</param>
            <param name="sheer">The sheer to use if you get bad results, try using a higher value.</param>
            <returns>A list of triangles</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.SeidelDecomposer.ConvexPartitionTrapezoid(tainicom.Aether.Physics2D.Common.Vertices,System.Single)">
            <summary>
            Decompose the polygon into several smaller non-concave polygons.
            </summary>
            <param name="vertices">The polygon to decompose.</param>
            <param name="sheer">The sheer to use if you get bad results, try using a higher value.</param>
            <returns>A list of trapezoids</returns>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.Decomposition.TriangulationAlgorithm.Earclip">
            <summary>
            Convex decomposition algorithm using ear clipping
            
            Properties:
            - Only works on simple polygons.
            - Does not support holes.
            - Running time is O(n^2), n = number of vertices.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.Decomposition.TriangulationAlgorithm.Bayazit">
            <summary>
            Convex decomposition algorithm created by Mark Bayazit (http://mnbayazit.com/)
            
            Properties:
            - Tries to decompose using polygons instead of triangles.
            - Tends to produce optimal results with low processing time.
            - Running time is O(nr), n = number of vertices, r = reflex vertices.
            - Does not support holes.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.Decomposition.TriangulationAlgorithm.Flipcode">
            <summary>
            Convex decomposition algorithm created by unknown
            
            Properties:
            - No support for holes
            - Very fast
            - Only works on simple polygons
            - Only works on counter clockwise polygons
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.Decomposition.TriangulationAlgorithm.Seidel">
            <summary>
            Convex decomposition algorithm created by Raimund Seidel
            
            Properties:
            - Decompose the polygon into trapezoids, then triangulate.
            - To use the trapezoid data, use ConvexPartitionTrapezoid()
            - Generate a lot of garbage due to incapsulation of the Poly2Tri library.
            - Running time is O(n log n), n = number of vertices.
            - Running time is almost linear for most simple polygons.
            - Does not care about winding order. 
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.Decomposition.TriangulationAlgorithm.Delauny">
            <summary>
            2D constrained Delaunay triangulation algorithm.
            Based on the paper "Sweep-line algorithm for constrained Delaunay triangulation" by V. Domiter and and B. Zalik
            
            Properties:
            - Creates triangles with a large interior angle.
            - Supports holes
            - Generate a lot of garbage due to incapsulation of the Poly2Tri library.
            - Running time is O(n^2), n = number of vertices.
            - Does not care about winding order.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Decomposition.Triangulate.ConvexPartition(tainicom.Aether.Physics2D.Common.Vertices,tainicom.Aether.Physics2D.Common.Decomposition.TriangulationAlgorithm,System.Boolean,System.Single,System.Boolean)">
            <param name="skipSanityChecks">
            Set this to true to skip sanity checks in the engine. This will speed up the
            tools by removing the overhead of the checks, but you will need to handle checks
            yourself where it is needed.
            </param>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.LineTools">
            <summary>
            Collection of helper methods for misc collisions.
            Does float tolerance and line collisions with lines and AABBs.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.LineTools.LineIntersect2(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
             <summary>
            Check if the lines a0->a1 and b0->b1 cross.
            If they do, intersectionPoint will be filled
            with the point of crossing.
            
            Grazing lines should not return true.
             
             </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.LineTools.LineIntersect(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,System.Boolean,System.Boolean,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            This method detects if two line segments (or lines) intersect,
            and, if so, the point of intersection. Use the <paramref name="firstIsSegment"/> and
            <paramref name="secondIsSegment"/> parameters to set whether the intersection point
            must be on the first and second line segments. Setting these
            both to true means you are doing a line-segment to line-segment
            intersection. Setting one of them to true means you are doing a
            line to line-segment intersection test, and so on.
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            Author: Jeremy Bell
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="point">This is set to the intersection
            point if an intersection is detected.</param>
            <param name="firstIsSegment">Set this to true to require that the 
            intersection point be on the first line segment.</param>
            <param name="secondIsSegment">Set this to true to require that the
            intersection point be on the second line segment.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.LineTools.LineIntersect(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Boolean,System.Boolean,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            This method detects if two line segments (or lines) intersect,
            and, if so, the point of intersection. Use the <paramref name="firstIsSegment"/> and
            <paramref name="secondIsSegment"/> parameters to set whether the intersection point
            must be on the first and second line segments. Setting these
            both to true means you are doing a line-segment to line-segment
            intersection. Setting one of them to true means you are doing a
            line to line-segment intersection test, and so on.
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            Author: Jeremy Bell
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="intersectionPoint">This is set to the intersection
            point if an intersection is detected.</param>
            <param name="firstIsSegment">Set this to true to require that the 
            intersection point be on the first line segment.</param>
            <param name="secondIsSegment">Set this to true to require that the
            intersection point be on the second line segment.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.LineTools.LineIntersect(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            This method detects if two line segments intersect,
            and, if so, the point of intersection. 
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="intersectionPoint">This is set to the intersection
            point if an intersection is detected.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.LineTools.LineIntersect(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            This method detects if two line segments intersect,
            and, if so, the point of intersection. 
            Note: If two line segments are coincident, then 
            no intersection is detected (there are actually
            infinite intersection points).
            </summary>
            <param name="point1">The first point of the first line segment.</param>
            <param name="point2">The second point of the first line segment.</param>
            <param name="point3">The first point of the second line segment.</param>
            <param name="point4">The second point of the second line segment.</param>
            <param name="intersectionPoint">This is set to the intersection
            point if an intersection is detected.</param>
            <returns>True if an intersection is detected, false otherwise.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.LineTools.LineSegmentVerticesIntersect(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,tainicom.Aether.Physics2D.Common.Vertices)">
            <summary>
            Get all intersections between a line segment and a list of vertices
            representing a polygon. The vertices reuse adjacent points, so for example
            edges one and two are between the first and second vertices and between the
            second and third vertices. The last edge is between vertex vertices.Count - 1
            and verts0. (ie, vertices from a Geometry or AABB)
            </summary>
            <param name="point1">The first point of the line segment to test</param>
            <param name="point2">The second point of the line segment to test.</param>
            <param name="vertices">The vertices, as described above</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.LineTools.LineSegmentAABBIntersect(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,tainicom.Aether.Physics2D.Collision.AABB)">
            <summary>
            Get all intersections between a line segment and an AABB. 
            </summary>
            <param name="point1">The first point of the line segment to test</param>
            <param name="point2">The second point of the line segment to test.</param>
            <param name="aabb">The AABB that is used for testing intersection.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.MathUtils.Cross(Microsoft.Xna.Framework.Vector3@,Microsoft.Xna.Framework.Vector3@)">
            Perform the cross product on two vectors.
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.MathUtils.Mul(tainicom.Aether.Physics2D.Common.Mat33,Microsoft.Xna.Framework.Vector3)">
            Multiply a matrix times a vector.
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.MathUtils.Mul22(tainicom.Aether.Physics2D.Common.Mat33,Microsoft.Xna.Framework.Vector2)">
            Multiply a matrix times a vector.
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.MathUtils.Skew(Microsoft.Xna.Framework.Vector2)">
            Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.MathUtils.IsValid(System.Single)">
            <summary>
            This function is used to ensure that a floating point number is
            not a NaN or infinity.
            </summary>
            <param name="x">The x.</param>
            <returns>
            	<c>true</c> if the specified x is valid; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.MathUtils.VectorAngle(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Return the angle between two vectors on a plane
            The angle is from vector 1 to vector 2, positive anticlockwise
            The result is between -pi -> pi
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.MathUtils.Dot(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            Perform the dot product on two vectors.
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.MathUtils.Dot(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2@)">
            Perform the dot product on two vectors.
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.MathUtils.Area(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Returns a positive number if c is to the left of the line going from a to b.
            </summary>
            <returns>Positive number if point is left, negative if point is right, 
            and 0 if points are collinear.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.MathUtils.Area(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Returns a positive number if c is to the left of the line going from a to b.
            </summary>
            <returns>Positive number if point is left, negative if point is right, 
            and 0 if points are collinear.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.MathUtils.IsCollinear(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,System.Single)">
            <summary>
            Determines if three vertices are collinear (ie. on a straight line)
            </summary>
            <param name="a">First vertex</param>
            <param name="b">Second vertex</param>
            <param name="c">Third vertex</param>
            <param name="tolerance">The tolerance</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.MathUtils.FloatEquals(System.Single,System.Single,System.Single)">
            <summary>
            Checks if a floating point Value is equal to another,
            within a certain tolerance.
            </summary>
            <param name="value1">The first floating point Value.</param>
            <param name="value2">The second floating point Value.</param>
            <param name="delta">The floating point tolerance.</param>
            <returns>True if the values are "equal", false otherwise.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.MathUtils.FloatInRange(System.Single,System.Single,System.Single)">
            <summary>
            Checks if a floating point Value is within a specified
            range of values (inclusive).
            </summary>
            <param name="value">The Value to check.</param>
            <param name="min">The minimum Value.</param>
            <param name="max">The maximum Value.</param>
            <returns>True if the Value is within the range specified,
            false otherwise.</returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.Mat22">
            <summary>
            A 2-by-2 matrix. Stored in column-major order.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Mat22.#ctor(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Construct this matrix using columns.
            </summary>
            <param name="c1">The c1.</param>
            <param name="c2">The c2.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Mat22.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Construct this matrix using scalars.
            </summary>
            <param name="a11">The a11.</param>
            <param name="a12">The a12.</param>
            <param name="a21">The a21.</param>
            <param name="a22">The a22.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Mat22.Set(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Initialize this matrix using columns.
            </summary>
            <param name="c1">The c1.</param>
            <param name="c2">The c2.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Mat22.SetIdentity">
            <summary>
            Set this to the identity matrix.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Mat22.SetZero">
            <summary>
            Set this matrix to all zeros.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Mat22.Solve(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Solve A * x = b, where b is a column vector. This is more efficient
            than computing the inverse in one-shot cases.
            </summary>
            <param name="b">The b.</param>
            <returns></returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.Mat33">
            <summary>
            A 3-by-3 matrix. Stored in column-major order.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Mat33.#ctor(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3)">
            <summary>
            Construct this matrix using columns.
            </summary>
            <param name="c1">The c1.</param>
            <param name="c2">The c2.</param>
            <param name="c3">The c3.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Mat33.SetZero">
            <summary>
            Set this matrix to all zeros.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Mat33.Solve33(Microsoft.Xna.Framework.Vector3)">
            <summary>
            Solve A * x = b, where b is a column vector. This is more efficient
            than computing the inverse in one-shot cases.
            </summary>
            <param name="b">The b.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Mat33.Solve22(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Solve A * x = b, where b is a column vector. This is more efficient
            than computing the inverse in one-shot cases. Solve only the upper
            2-by-2 matrix equation.
            </summary>
            <param name="b">The b.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Mat33.GetInverse22(tainicom.Aether.Physics2D.Common.Mat33@)">
            Get the inverse of this matrix as a 2-by-2.
            Returns the zero matrix if singular.
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Mat33.GetSymInverse33(tainicom.Aether.Physics2D.Common.Mat33@)">
            Get the symmetric inverse of this matrix as a 3-by-3.
            Returns the zero matrix if singular.
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.Transform">
            <summary>
            A transform contains translation and rotation. It is used to represent
            the position and orientation of rigid frames.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Transform.#ctor(Microsoft.Xna.Framework.Vector2,tainicom.Aether.Physics2D.Common.Complex)">
            <summary>
            Initialize using a position vector and a Complex rotation.
            </summary>
            <param name="position">The position.</param>
            <param name="rotation">The rotation</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Transform.#ctor(Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            Initialize using a position vector and a rotation.
            </summary>
            <param name="position">The position.</param>
            <param name="angle">The rotation angle</param>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.Sweep">
            <summary>
            This describes the motion of a body/shape for TOI computation.
            Shapes are defined with respect to the body origin, which may
            no coincide with the center of mass. However, to support dynamics
            we must interpolate the center of mass position.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.Sweep.A">
            <summary>
            World angles
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.Sweep.Alpha0">
            <summary>
            Fraction of the current time step in the range [0,1]
            c0 and a0 are the positions at alpha0.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.Sweep.C">
            <summary>
            Center world positions
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.Sweep.LocalCenter">
            <summary>
            Local center of mass position
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Sweep.GetTransform(tainicom.Aether.Physics2D.Common.Transform@,System.Single)">
            <summary>
            Get the interpolated transform at a specific time.
            </summary>
            <param name="xfb">The transform.</param>
            <param name="beta">beta is a factor in [0,1], where 0 indicates alpha0.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Sweep.Advance(System.Single)">
            <summary>
            Advance the sweep forward, yielding a new initial state.
            </summary>
            <param name="alpha">new initial time..</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Sweep.Normalize">
            <summary>
            Normalize the angles.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.Path">
            <summary>
            Path:
            Very similar to Vertices, but this
            class contains vectors describing
            control points on a Catmull-Rom
            curve.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.Path.ControlPoints">
            <summary>
            All the points that makes up the curve
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Path.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:tainicom.Aether.Physics2D.Common.Path"/> class.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Path.#ctor(Microsoft.Xna.Framework.Vector2[])">
            <summary>
            Initializes a new instance of the <see cref="T:tainicom.Aether.Physics2D.Common.Path"/> class.
            </summary>
            <param name="vertices">The vertices to created the path from.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Path.#ctor(System.Collections.Generic.IList{Microsoft.Xna.Framework.Vector2})">
            <summary>
            Initializes a new instance of the <see cref="T:tainicom.Aether.Physics2D.Common.Path"/> class.
            </summary>
            <param name="vertices">The vertices to created the path from.</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Common.Path.Closed">
            <summary>
            True if the curve is closed.
            </summary>
            <value><c>true</c> if closed; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Path.NextIndex(System.Int32)">
            <summary>
            Gets the next index of a controlpoint
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Path.PreviousIndex(System.Int32)">
            <summary>
            Gets the previous index of a controlpoint
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Path.Translate(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Translates the control points by the specified vector.
            </summary>
            <param name="vector">The vector.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Path.Scale(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Scales the control points by the specified vector.
            </summary>
            <param name="value">The Value.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Path.Rotate(System.Single)">
            <summary>
            Rotate the control points by the defined value in radians.
            </summary>
            <param name="value">The amount to rotate by in radians.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Path.GetVertices(System.Int32)">
            <summary>
            Returns a set of points defining the
            curve with the specifed number of divisions
            between each control point.
            </summary>
            <param name="divisions">Number of divisions between each control point.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Path.GetPositionNormal(System.Single)">
            <summary>
            Gets the normal for the given time.
            </summary>
            <param name="time">The time</param>
            <returns>The normal.</returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.PathManager">
            <summary>
            An easy to use manager for creating paths.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PathManager.ConvertPathToEdges(tainicom.Aether.Physics2D.Common.Path,tainicom.Aether.Physics2D.Dynamics.Body,System.Int32)">
            <summary>
            Convert a path into a set of edges and attaches them to the specified body.
            Note: use only for static edges.
            </summary>
            <param name="path">The path.</param>
            <param name="body">The body.</param>
            <param name="subdivisions">The subdivisions.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PathManager.ConvertPathToPolygon(tainicom.Aether.Physics2D.Common.Path,tainicom.Aether.Physics2D.Dynamics.Body,System.Single,System.Int32)">
            <summary>
            Convert a closed path into a polygon.
            Convex decomposition is automatically performed.
            </summary>
            <param name="path">The path.</param>
            <param name="body">The body.</param>
            <param name="density">The density.</param>
            <param name="subdivisions">The subdivisions.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PathManager.EvenlyDistributeShapesAlongPath(tainicom.Aether.Physics2D.Dynamics.World,tainicom.Aether.Physics2D.Common.Path,System.Collections.Generic.IEnumerable{tainicom.Aether.Physics2D.Collision.Shapes.Shape},tainicom.Aether.Physics2D.Dynamics.BodyType,System.Int32,System.Object)">
            <summary>
            Duplicates the given Body along the given path for approximatly the given copies.
            </summary>
            <param name="world">The world.</param>
            <param name="path">The path.</param>
            <param name="shapes">The shapes.</param>
            <param name="type">The type.</param>
            <param name="copies">The copies.</param>
            <param name="userData"></param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PathManager.EvenlyDistributeShapesAlongPath(tainicom.Aether.Physics2D.Dynamics.World,tainicom.Aether.Physics2D.Common.Path,tainicom.Aether.Physics2D.Collision.Shapes.Shape,tainicom.Aether.Physics2D.Dynamics.BodyType,System.Int32,System.Object)">
            <summary>
            Duplicates the given Body along the given path for approximatly the given copies.
            </summary>
            <param name="world">The world.</param>
            <param name="path">The path.</param>
            <param name="shape">The shape.</param>
            <param name="type">The type.</param>
            <param name="copies">The copies.</param>
            <param name="userData">The user data.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PathManager.MoveBodyOnPath(tainicom.Aether.Physics2D.Common.Path,tainicom.Aether.Physics2D.Dynamics.Body,System.Single,System.Single,System.Single)">
            <summary>
            Moves the given body along the defined path.
            </summary>
            <param name="path">The path.</param>
            <param name="body">The body.</param>
            <param name="time">The time.</param>
            <param name="strength">The strength.</param>
            <param name="timeStep">The time step.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PathManager.AttachBodiesWithRevoluteJoint(tainicom.Aether.Physics2D.Dynamics.World,System.Collections.Generic.List{tainicom.Aether.Physics2D.Dynamics.Body},Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Boolean,System.Boolean)">
            <summary>
            Attaches the bodies with revolute joints.
            </summary>
            <param name="world">The world.</param>
            <param name="bodies">The bodies.</param>
            <param name="localAnchorA">The local anchor A.</param>
            <param name="localAnchorB">The local anchor B.</param>
            <param name="connectFirstAndLast">if set to <c>true</c> [connect first and last].</param>
            <param name="collideConnected">if set to <c>true</c> [collide connected].</param>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.PhysicsLogic.BreakableBody">
            <summary>
            A type of body that supports multiple fixtures that can break apart.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.PhysicsLogic.BreakableBody.Strength">
            <summary>
            The force needed to break the body apart.
            Default: 500
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PhysicsLogic.ControllerFilter.IgnoreController(tainicom.Aether.Physics2D.Common.PhysicsLogic.ControllerCategory)">
            <summary>
            Ignores the controller. The controller has no effect on this body.
            </summary>
            <param name="type">The logic type.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PhysicsLogic.ControllerFilter.RestoreController(tainicom.Aether.Physics2D.Common.PhysicsLogic.ControllerCategory)">
            <summary>
            Restore the controller. The controller affects this body.
            </summary>
            <param name="category">The logic type.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PhysicsLogic.ControllerFilter.IsControllerIgnored(tainicom.Aether.Physics2D.Common.PhysicsLogic.ControllerCategory)">
            <summary>
            Determines whether this body ignores the the specified controller.
            </summary>
            <param name="category">The logic type.</param>
            <returns>
            	<c>true</c> if the body has the specified flag; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.PhysicsLogic.FilterData">
            <summary>
            Contains filter data that can determine whether an object should be processed or not.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.PhysicsLogic.FilterData.DisabledOnCategories">
            <summary>
            Disable the logic on specific categories.
            Category.None by default.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.PhysicsLogic.FilterData.DisabledOnGroup">
            <summary>
            Disable the logic on specific groups
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.PhysicsLogic.FilterData.EnabledOnCategories">
            <summary>
            Enable the logic on specific categories
            Category.All by default.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.PhysicsLogic.FilterData.EnabledOnGroup">
            <summary>
            Enable the logic on specific groups.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PhysicsLogic.FilterData.IsActiveOn(tainicom.Aether.Physics2D.Dynamics.Body)">
            <summary>
            
            </summary>
            <param name="body"></param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PhysicsLogic.FilterData.AddDisabledCategory(tainicom.Aether.Physics2D.Dynamics.Category)">
            <summary>
            Adds the category.
            </summary>
            <param name="category">The category.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PhysicsLogic.FilterData.RemoveDisabledCategory(tainicom.Aether.Physics2D.Dynamics.Category)">
            <summary>
            Removes the category.
            </summary>
            <param name="category">The category.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PhysicsLogic.FilterData.IsInDisabledCategory(tainicom.Aether.Physics2D.Dynamics.Category)">
            <summary>
            Determines whether this body ignores the the specified controller.
            </summary>
            <param name="category">The category.</param>
            <returns>
            	<c>true</c> if the object has the specified category; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PhysicsLogic.FilterData.AddEnabledCategory(tainicom.Aether.Physics2D.Dynamics.Category)">
            <summary>
            Adds the category.
            </summary>
            <param name="category">The category.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PhysicsLogic.FilterData.RemoveEnabledCategory(tainicom.Aether.Physics2D.Dynamics.Category)">
            <summary>
            Removes the category.
            </summary>
            <param name="category">The category.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PhysicsLogic.FilterData.IsInEnabledInCategory(tainicom.Aether.Physics2D.Dynamics.Category)">
            <summary>
            Determines whether this body ignores the the specified controller.
            </summary>
            <param name="category">The category.</param>
            <returns>
            	<c>true</c> if the object has the specified category; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.PhysicsLogic.RayDataComparer">
            <summary>
            This is a comprarer used for 
            detecting angle difference between rays
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.PhysicsLogic.RealExplosion">
            <summary>
            Creates a realistic explosion based on raycasting. Objects in the open will be affected, but objects behind
            static bodies will not. A body that is half in cover, half in the open will get half the force applied to the end in
            the open.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.PhysicsLogic.RealExplosion.MaxEdgeOffset">
            <summary>
            Two degrees: maximum angle from edges to first ray tested
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.PhysicsLogic.RealExplosion.EdgeRatio">
            <summary>
            Ratio of arc length to angle from edges to first ray tested.
            Defaults to 1/40.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.PhysicsLogic.RealExplosion.IgnoreWhenInsideShape">
            <summary>
            Ignore Explosion if it happens inside a shape.
            Default value is false.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.PhysicsLogic.RealExplosion.MaxAngle">
            <summary>
            Max angle between rays (used when segment is large).
            Defaults to 15 degrees
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.PhysicsLogic.RealExplosion.MaxShapes">
            <summary>
            Maximum number of shapes involved in the explosion.
            Defaults to 100
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.PhysicsLogic.RealExplosion.MinRays">
            <summary>
            How many rays per shape/body/segment.
            Defaults to 5
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PhysicsLogic.RealExplosion.Activate(Microsoft.Xna.Framework.Vector2,System.Single,System.Single)">
            <summary>
            Activate the explosion at the specified position.
            </summary>
            <param name="pos">The position where the explosion happens </param>
            <param name="radius">The explosion radius </param>
            <param name="maxForce">The explosion force at the explosion point (then is inversely proportional to the square of the distance)</param>
            <returns>A list of bodies and the amount of force that was applied to them.</returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.PhysicsLogic.SimpleExplosion">
            <summary>
            Creates a simple explosion that ignores other bodies hiding behind static bodies.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Common.PhysicsLogic.SimpleExplosion.Power">
            <summary>
            This is the power used in the power function. A value of 1 means the force
            applied to bodies in the explosion is linear. A value of 2 means it is exponential.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PhysicsLogic.SimpleExplosion.Activate(Microsoft.Xna.Framework.Vector2,System.Single,System.Single,System.Single)">
            <summary>
            Activate the explosion at the specified position.
            </summary>
            <param name="pos">The position (center) of the explosion.</param>
            <param name="radius">The radius of the explosion.</param>
            <param name="force">The force applied</param>
            <param name="maxForce">A maximum amount of force. When force gets over this value, it will be equal to maxForce</param>
            <returns>A list of bodies and the amount of force that was applied to them.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.CuttingTools.SplitShape(tainicom.Aether.Physics2D.Dynamics.Fixture,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,tainicom.Aether.Physics2D.Common.Vertices@,tainicom.Aether.Physics2D.Common.Vertices@)">
            <summary>
            Split a fixture into 2 vertice collections using the given entry and exit-point.
            </summary>
            <param name="fixture">The Fixture to split</param>
            <param name="entryPoint">The entry point - The start point</param>
            <param name="exitPoint">The exit point - The end point</param>
            <param name="first">The first collection of vertexes</param>
            <param name="second">The second collection of vertexes</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.CuttingTools.Cut(tainicom.Aether.Physics2D.Dynamics.World,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            This is a high-level function to cuts fixtures inside the given world, using the start and end points.
            Note: We don't support cutting when the start or end is inside a shape.
            </summary>
            <param name="world">The world.</param>
            <param name="start">The startpoint.</param>
            <param name="end">The endpoint.</param>
            <returns>True if the cut was performed.</returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.PolygonManipulation.SimpleCombiner">
            <summary>
            Combines a list of triangles into a list of convex polygons.
            Starts with a seed triangle, keep adding triangles to it until you can't add any more without making the polygon non-convex.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.SimpleCombiner.PolygonizeTriangles(System.Collections.Generic.List{tainicom.Aether.Physics2D.Common.Vertices},System.Int32,System.Single)">
             <summary>
             Combine a list of triangles into a list of convex polygons.
             
             Note: This only works on triangles.
             </summary>
            <param name="triangles">The triangles.</param>
            <param name="maxPolys">The maximun number of polygons to return.</param>
            <param name="tolerance">The tolerance</param>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.PolygonManipulation.SimplifyTools">
            <summary>
            Provides a set of tools to simplify polygons in various ways.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.SimplifyTools.CollinearSimplify(tainicom.Aether.Physics2D.Common.Vertices,System.Single)">
            <summary>
            Removes all collinear points on the polygon.
            </summary>
            <param name="vertices">The polygon that needs simplification.</param>
            <param name="collinearityTolerance">The collinearity tolerance.</param>
            <returns>A simplified polygon.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.SimplifyTools.DouglasPeuckerSimplify(tainicom.Aether.Physics2D.Common.Vertices,System.Single)">
            <summary>
            Ramer-Douglas-Peucker polygon simplification algorithm. This is the general recursive version that does not use the
            speed-up technique by using the Melkman convex hull.
            
            If you pass in 0, it will remove all collinear points.
            </summary>
            <returns>The simplified polygon</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.SimplifyTools.MergeParallelEdges(tainicom.Aether.Physics2D.Common.Vertices,System.Single)">
            <summary>
            Merges all parallel edges in the list of vertices
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="tolerance">The tolerance.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.SimplifyTools.MergeIdenticalPoints(tainicom.Aether.Physics2D.Common.Vertices)">
            <summary>
            Merges the identical points in the polygon.
            </summary>
            <param name="vertices">The vertices.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.SimplifyTools.ReduceByDistance(tainicom.Aether.Physics2D.Common.Vertices,System.Single)">
            <summary>
            Reduces the polygon by distance.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="distance">The distance between points. Points closer than this will be removed.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.SimplifyTools.ReduceByNth(tainicom.Aether.Physics2D.Common.Vertices,System.Int32)">
            <summary>
            Reduces the polygon by removing the Nth vertex in the vertices list.
            </summary>
            <param name="vertices">The vertices.</param>
            <param name="nth">The Nth point to remove. Example: 5.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.SimplifyTools.ReduceByArea(tainicom.Aether.Physics2D.Common.Vertices,System.Single)">
            <summary>
            Simplify the polygon by removing all points that in pairs of 3 have an area less than the tolerance.
            
            Pass in 0 as tolerance, and it will only remove collinear points.
            </summary>
            <param name="vertices"></param>
            <param name="areaTolerance"></param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.YuPengClipper.Execute(tainicom.Aether.Physics2D.Common.Vertices,tainicom.Aether.Physics2D.Common.Vertices,tainicom.Aether.Physics2D.Common.PolygonManipulation.PolyClipType,tainicom.Aether.Physics2D.Common.PolygonManipulation.PolyClipError@)">
            <summary>
            Implements "A new algorithm for Boolean operations on general polygons" 
            available here: http://liama.ia.ac.cn/wiki/_media/user:dong:dong_cg_05.pdf
            Merges two polygons, a subject and a clip with the specified operation. Polygons may not be 
            self-intersecting.
            
            Warning: May yield incorrect results or even crash if polygons contain collinear points.
            </summary>
            <param name="subject">The subject polygon.</param>
            <param name="clip">The clip polygon, which is added, 
            substracted or intersected with the subject</param>
            <param name="clipType">The operation to be performed. Either
            Union, Difference or Intersection.</param>
            <param name="error">The error generated (if any)</param>
            <returns>A list of closed polygons, which make up the result of the clipping operation.
            Outer contours are ordered counter clockwise, holes are ordered clockwise.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.YuPengClipper.CalculateIntersections(tainicom.Aether.Physics2D.Common.Vertices,tainicom.Aether.Physics2D.Common.Vertices,tainicom.Aether.Physics2D.Common.Vertices@,tainicom.Aether.Physics2D.Common.Vertices@)">
            <summary>
            Calculates all intersections between two polygons.
            </summary>
            <param name="polygon1">The first polygon.</param>
            <param name="polygon2">The second polygon.</param>
            <param name="slicedPoly1">Returns the first polygon with added intersection points.</param>
            <param name="slicedPoly2">Returns the second polygon with added intersection points.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.YuPengClipper.CalculateSimplicalChain(tainicom.Aether.Physics2D.Common.Vertices,System.Collections.Generic.List{System.Single}@,System.Collections.Generic.List{tainicom.Aether.Physics2D.Common.PolygonManipulation.YuPengClipper.Edge}@)">
            <summary>
            Calculates the simplical chain corresponding to the input polygon.
            </summary>
            <remarks>Used by method <c>Execute()</c>.</remarks>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.YuPengClipper.CalculateResultChain(System.Collections.Generic.List{System.Single},System.Collections.Generic.List{tainicom.Aether.Physics2D.Common.PolygonManipulation.YuPengClipper.Edge},System.Collections.Generic.List{System.Single},System.Collections.Generic.List{tainicom.Aether.Physics2D.Common.PolygonManipulation.YuPengClipper.Edge},tainicom.Aether.Physics2D.Common.PolygonManipulation.PolyClipType,System.Collections.Generic.List{tainicom.Aether.Physics2D.Common.PolygonManipulation.YuPengClipper.Edge}@)">
            <summary>
            Calculates the characteristics function for all edges of
            the given simplical chains and builds the result chain.
            </summary>
            <remarks>Used by method <c>Execute()</c>.</remarks>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.YuPengClipper.BuildPolygonsFromChain(System.Collections.Generic.List{tainicom.Aether.Physics2D.Common.PolygonManipulation.YuPengClipper.Edge},System.Collections.Generic.List{tainicom.Aether.Physics2D.Common.Vertices}@)">
            <summary>
            Calculates the polygon(s) from the result simplical chain.
            </summary>
            <remarks>Used by method <c>Execute()</c>.</remarks>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.YuPengClipper.CalculateBeta(Microsoft.Xna.Framework.Vector2,tainicom.Aether.Physics2D.Common.PolygonManipulation.YuPengClipper.Edge,System.Single)">
            <summary>
            Needed to calculate the characteristics function of a simplex.
            </summary>
            <remarks>Used by method <c>CalculateEdgeCharacter()</c>.</remarks>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.YuPengClipper.GetAlpha(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Needed for sorting multiple intersections points on the same edge.
            </summary>
            <remarks>Used by method <c>CalculateIntersections()</c>.</remarks>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.YuPengClipper.CalculateSimplexCoefficient(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Returns the coefficient of a simplex.
            </summary>
            <remarks>Used by method <c>CalculateSimplicalChain()</c>.</remarks>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.YuPengClipper.PointInSimplex(Microsoft.Xna.Framework.Vector2,tainicom.Aether.Physics2D.Common.PolygonManipulation.YuPengClipper.Edge)">
            <summary>
            Winding number test for a point in a simplex.
            </summary>
            <param name="point">The point to be tested.</param>
            <param name="edge">The edge that the point is tested against.</param>
            <returns>False if the winding number is even and the point is outside
            the simplex and True otherwise.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonManipulation.YuPengClipper.PointOnLineSegment(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Tests if a point lies on a line segment.
            </summary>
            <remarks>Used by method <c>CalculateBeta()</c>.</remarks>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.PolygonManipulation.YuPengClipper.Edge">
            <summary>Specifies an Edge. Edges are used to represent simplicies in simplical chains</summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonTools.CreateRectangle(System.Single,System.Single)">
            <summary>
            Build vertices to represent an axis-aligned box.
            </summary>
            <param name="hx">the half-width.</param>
            <param name="hy">the half-height.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonTools.CreateRectangle(System.Single,System.Single,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            Build vertices to represent an oriented box.
            </summary>
            <param name="hx">the half-width.</param>
            <param name="hy">the half-height.</param>
            <param name="center">the center of the box in local coordinates.</param>
            <param name="angle">the rotation of the box in local coordinates.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonTools.CreateRoundedRectangle(System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Creates a rounded rectangle with the specified width and height.
            </summary>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="xRadius">The rounding X radius.</param>
            <param name="yRadius">The rounding Y radius.</param>
            <param name="segments">The number of segments to subdivide the edges.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonTools.CreateLine(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Set this as a single edge.
            </summary>
            <param name="start">The first point.</param>
            <param name="end">The second point.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonTools.CreateCircle(System.Single,System.Int32)">
            <summary>
            Creates a circle with the specified radius and number of edges.
            </summary>
            <param name="radius">The radius.</param>
            <param name="numberOfEdges">The number of edges. The more edges, the more it resembles a circle</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonTools.CreateEllipse(System.Single,System.Single,System.Int32)">
            <summary>
            Creates a ellipse with the specified width, height and number of edges.
            </summary>
            <param name="xRadius">Width of the ellipse.</param>
            <param name="yRadius">Height of the ellipse.</param>
            <param name="numberOfEdges">The number of edges. The more edges, the more it resembles an ellipse</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonTools.CreateCapsule(System.Single,System.Single,System.Int32)">
            <summary>
            Creates an capsule with the specified height, radius and number of edges.
            A capsule has the same form as a pill capsule.
            </summary>
            <param name="height">Height (inner height + 2 * radius) of the capsule.</param>
            <param name="endRadius">Radius of the capsule ends.</param>
            <param name="edges">The number of edges of the capsule ends. The more edges, the more it resembles an capsule</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonTools.CreateCapsule(System.Single,System.Single,System.Int32,System.Single,System.Int32)">
            <summary>
            Creates an capsule with the specified  height, radius and number of edges.
            A capsule has the same form as a pill capsule.
            </summary>
            <param name="height">Height (inner height + radii) of the capsule.</param>
            <param name="topRadius">Radius of the top.</param>
            <param name="topEdges">The number of edges of the top. The more edges, the more it resembles an capsule</param>
            <param name="bottomRadius">Radius of bottom.</param>
            <param name="bottomEdges">The number of edges of the bottom. The more edges, the more it resembles an capsule</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonTools.CreateGear(System.Single,System.Int32,System.Single,System.Single)">
            <summary>
            Creates a gear shape with the specified radius and number of teeth.
            </summary>
            <param name="radius">The radius.</param>
            <param name="numberOfTeeth">The number of teeth.</param>
            <param name="tipPercentage">The tip percentage.</param>
            <param name="toothHeight">Height of the tooth.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonTools.CreatePolygon(System.UInt32[],System.Int32)">
            <summary>
            Detects the vertices by analyzing the texture data.
            </summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonTools.CreatePolygon(System.UInt32[],System.Int32,System.Boolean)">
            <summary>
            Detects the vertices by analyzing the texture data.
            </summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <param name="holeDetection">if set to <c>true</c> it will perform hole detection.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.PolygonTools.CreatePolygon(System.UInt32[],System.Int32,System.Single,System.Byte,System.Boolean,System.Boolean)">
            <summary>
            Detects the vertices by analyzing the texture data.
            </summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <param name="hullTolerance">The hull tolerance.</param>
            <param name="alphaTolerance">The alpha tolerance.</param>
            <param name="multiPartDetection">if set to <c>true</c> it will perform multi part detection.</param>
            <param name="holeDetection">if set to <c>true</c> it will perform hole detection.</param>
            <returns></returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.WorldSerializer">
            <summary>
            Serialize the world into an XML file
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.WorldSerializer.Serialize(tainicom.Aether.Physics2D.Dynamics.World,System.IO.Stream)">
            <summary>
            Serialize the world to a stream in XML format
            </summary>
            <param name="world"></param>
            <param name="stream"></param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.WorldSerializer.Deserialize(System.IO.Stream)">
            <summary>
            Deserialize the world from a stream XML
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.DetectSquares(tainicom.Aether.Physics2D.Collision.AABB,System.Single,System.Single,System.SByte[0:,0:],System.Int32,System.Boolean)">
             <summary>
             Marching squares over the given domain using the mesh defined via the dimensions
                (wid,hei) to build a set of polygons such that f(x,y) less than 0, using the given number
                'bin' for recursive linear inteprolation along cell boundaries.
            
                if 'comb' is true, then the polygons will also be composited into larger possible concave
                polygons.
             </summary>
             <param name="domain"></param>
             <param name="cellWidth"></param>
             <param name="cellHeight"></param>
             <param name="f"></param>
             <param name="lerpCount"></param>
             <param name="combine"></param>
             <returns></returns>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares._lookMarch">
            Linearly interpolate between (x0 to x1) given a value at these coordinates (v0 and v1)
                        such as to approximate value(return) = 0
                    *
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.Xlerp(System.Single,System.Single,System.Single,System.Single,System.Single,System.SByte[0:,0:],System.Int32)">
            Recursive linear interpolation for use in marching squares *
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.Ylerp(System.Single,System.Single,System.Single,System.Single,System.Single,System.SByte[0:,0:],System.Int32)">
            Recursive linear interpolation for use in marching squares *
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.Square(System.Single)">
            Square value for use in marching squares *
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.MarchSquare(System.SByte[0:,0:],System.SByte[0:,0:],tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.GeomPoly@,System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            Look-up table to relate polygon key with the vertices that should be used for
                        the sub polygon in marching squares
                    *
            Perform a single celled marching square for for the given cell defined by (x0,y0) (x1,y1)
                        using the function f for recursive interpolation, given the look-up table 'fs' of
                        the values of 'f' at cell vertices with the result to be stored in 'poly' given the actual
                        coordinates of 'ax' 'ay' in the marching squares mesh.
                    *
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.combLeft(tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.GeomPoly@,tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.GeomPoly@)">
            Used in polygon composition to composit polygons into scan lines
                        Combining polya and polyb into one super-polygon stored in polya.
                    *
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.CxFastList`1">
            <summary>
            Designed as a complete port of CxFastList from CxStd.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.CxFastList`1.Begin">
            <summary>
            Iterator to start of list (O(1))
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.CxFastList`1.End">
            <summary>
            Iterator to end of list (O(1))
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.CxFastList`1.Front">
            <summary>
            Returns first element of list (O(1))
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.CxFastList`1.Add(`0)">
            <summary>
            add object to list (O(1))
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.CxFastList`1.Remove(`0)">
            <summary>
            remove object from list, returns true if an element was removed (O(n))
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.CxFastList`1.Pop">
            <summary>
            pop element from head of list (O(1)) Note: this does not return the object popped! 
            There is good reason to this, and it regards the Alloc list variants which guarantee 
            objects are released to the object pool. You do not want to retrieve an element 
            through pop or else that object may suddenly be used by another piece of code which 
            retrieves it from the object pool.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.CxFastList`1.Insert(tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.CxFastListNode{`0},`0)">
            <summary>
            insert object after 'node' returning an iterator to the inserted object.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.CxFastList`1.Erase(tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.CxFastListNode{`0},tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.CxFastListNode{`0})">
            <summary>
            removes the element pointed to by 'node' with 'prev' being the previous iterator, 
            returning an iterator to the element following that of 'node' (O(1))
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.CxFastList`1.Empty">
            <summary>
            whether the list is empty (O(1))
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.CxFastList`1.Size">
            <summary>
            computes size of list (O(n))
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.CxFastList`1.Clear">
            <summary>
            empty the list (O(1) if CxMixList, O(n) otherwise)
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.CxFastList`1.Has(`0)">
            <summary>
            returns true if 'value' is an element of the list (O(n))
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.TextureTools.MarchingSquares.GeomPolyVal.Key">
            Associated polygon at coordinate *
            Key of original sub-polygon *
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.TextureTools.Terrain">
            <summary>
            Simple class to maintain a terrain. It can keep track
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.TextureTools.Terrain.World">
            <summary>
            World to manage terrain in.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.TextureTools.Terrain.Center">
            <summary>
            Center of terrain in world units.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.TextureTools.Terrain.Width">
            <summary>
            Width of terrain in world units.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.TextureTools.Terrain.Height">
            <summary>
            Height of terrain in world units.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.TextureTools.Terrain.PointsPerUnit">
            <summary>
            Points per each world unit used to define the terrain in the point cloud.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.TextureTools.Terrain.CellSize">
            <summary>
            Points per cell.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.TextureTools.Terrain.SubCellSize">
            <summary>
            Points per sub cell.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.TextureTools.Terrain.Iterations">
            <summary>
            Number of iterations to perform in the Marching Squares algorithm.
            Note: More then 3 has almost no effect on quality.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.TextureTools.Terrain.Decomposer">
            <summary>
            Decomposer to use when regenerating terrain. Can be changed on the fly without consequence.
            Note: Some decomposerers are unstable.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.TextureTools.Terrain._terrainMap">
            <summary>
            Point cloud defining the terrain.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.TextureTools.Terrain._bodyMap">
            <summary>
            Generated bodies.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.Terrain.#ctor(tainicom.Aether.Physics2D.Dynamics.World,tainicom.Aether.Physics2D.Collision.AABB)">
            <summary>
            Creates a new terrain.
            </summary>
            <param name="world">The World</param>
            <param name="area">The area of the terrain.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.Terrain.#ctor(tainicom.Aether.Physics2D.Dynamics.World,Microsoft.Xna.Framework.Vector2,System.Single,System.Single)">
            <summary>
            Creates a new terrain
            </summary>
            <param name="world">The World</param>
            <param name="position">The position (center) of the terrain.</param>
            <param name="width">The width of the terrain.</param>
            <param name="height">The height of the terrain.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.Terrain.Initialize">
            <summary>
            Initialize the terrain for use.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.Terrain.ApplyData(System.SByte[0:,0:],Microsoft.Xna.Framework.Vector2)">
            <summary>
            Apply the specified texture data to the terrain.
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.Terrain.ModifyTerrain(Microsoft.Xna.Framework.Vector2,System.SByte)">
            <summary>
            Modify a single point in the terrain.
            </summary>
            <param name="location">World location to modify. Automatically clipped.</param>
            <param name="value">-1 = inside terrain, 1 = outside terrain</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.Terrain.RegenerateTerrain">
            <summary>
            Regenerate the terrain.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Common.TextureTools.VerticesDetectionType">
            <summary>
            The detection type affects the resulting polygon data.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.TextureTools.VerticesDetectionType.Integrated">
            <summary>
            Holes are integrated into the main polygon.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.TextureTools.VerticesDetectionType.Separated">
            <summary>
            The data of the main polygon and hole polygons is returned separately.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.TextureTools.TextureConverter._closePixels">
            <summary>
            This array is ment to be readonly.
            It's not because it is accessed very frequently.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Common.TextureTools.TextureConverter.PolygonDetectionType">
            <summary>
            Get or set the polygon detection type.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Common.TextureTools.TextureConverter.HoleDetection">
            <summary>
            Will detect texture 'holes' if set to true. Slows down the detection. Default is false.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Common.TextureTools.TextureConverter.MultipartDetection">
            <summary>
            Will detect texture multiple 'solid' isles if set to true. Slows down the detection. Default is false.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Common.TextureTools.TextureConverter.PixelOffsetOptimization">
            <summary>
            Will optimize the vertex positions along the interpolated normal between two edges about a half pixel (post processing). Default is false.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Common.TextureTools.TextureConverter.Transform">
            <summary>
            Can be used for scaling.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Common.TextureTools.TextureConverter.AlphaTolerance">
            <summary>
            Alpha (coverage) tolerance. Default is 20: Every pixel with a coverage value equal or greater to 20 will be counts as solid.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Common.TextureTools.TextureConverter.HullTolerance">
            <summary>
            Default is 1.5f.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.TextureConverter.DetectVertices(System.UInt32[],System.Int32)">
            <summary>
            Detects the vertices of the supplied texture data. (PolygonDetectionType.Integrated)
            </summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.TextureConverter.DetectVertices(System.UInt32[],System.Int32,System.Boolean)">
            <summary>
            Detects the vertices of the supplied texture data.
            </summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <param name="holeDetection">if set to <c>true</c> it will perform hole detection.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.TextureConverter.DetectVertices(System.UInt32[],System.Int32,System.Single,System.Byte,System.Boolean,System.Boolean)">
            <summary>
            Detects the vertices of the supplied texture data.
            </summary>
            <param name="data">The texture data.</param>
            <param name="width">The texture width.</param>
            <param name="holeDetection">if set to <c>true</c> it will perform hole detection.</param>
            <param name="hullTolerance">The hull tolerance.</param>
            <param name="alphaTolerance">The alpha tolerance.</param>
            <param name="multiPartDetection">if set to <c>true</c> it will perform multi part detection.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.TextureConverter.SearchHoleEntrance(tainicom.Aether.Physics2D.Common.Vertices,System.Nullable{Microsoft.Xna.Framework.Vector2})">
            <summary>
            Function to search for an entrance point of a hole in a polygon. It searches the polygon from top to bottom between the polygon edges.
            </summary>
            <param name="polygon">The polygon to search in.</param>
            <param name="lastHoleEntrance">The last entrance point.</param>
            <returns>The next holes entrance point. Null if ther are no holes.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.TextureConverter.SearchCrossingEdges(tainicom.Aether.Physics2D.Common.Vertices,System.Int32)">
            <summary>
            Searches the polygon for the x coordinates of the edges that cross the specified y coordinate.
            </summary>
            <param name="polygon">Polygon to search in.</param>
            <param name="y">Y coordinate to check for edges.</param>
            <returns>Descending sorted list of x coordinates of edges that cross the specified y coordinate.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.TextureConverter.CreateSimplePolygon(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            
            </summary>
            <param name="entrance"></param>
            <param name="last"></param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.TextureTools.TextureConverter.SearchNextHullEntrance(System.Collections.Generic.List{tainicom.Aether.Physics2D.Common.Vertices},Microsoft.Xna.Framework.Vector2,System.Nullable{Microsoft.Xna.Framework.Vector2}@)">
            <summary>
            Searches for the next shape.
            </summary>
            <param name="detectedPolygons">Already detected polygons.</param>
            <param name="start">Search start coordinate.</param>
            <param name="entrance">Returns the found entrance coordinate. Null if no other shapes found.</param>
            <returns>True if a new shape was found.</returns>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.PolygonError.NoError">
            <summary>
            There were no errors in the polygon
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.PolygonError.InvalidAmountOfVertices">
            <summary>
            Polygon must have between 3 and Settings.MaxPolygonVertices vertices.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.PolygonError.NotSimple">
            <summary>
            Polygon must be simple. This means no overlapping edges.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.PolygonError.NotCounterClockWise">
            <summary>
            Polygon must have a counter clockwise winding.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.PolygonError.NotConvex">
            <summary>
            The polygon is concave, it needs to be convex.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.PolygonError.AreaTooSmall">
            <summary>
            Polygon area is too small.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Common.PolygonError.SideTooSmall">
            <summary>
            The polygon has a side that is too short.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Common.Vertices.Holes">
            <summary>
            You can add holes to this collection.
            It will get respected by some of the triangulation algoithms, but otherwise not used.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.NextIndex(System.Int32)">
            <summary>
            Gets the next index. Used for iterating all the edges with wrap-around.
            </summary>
            <param name="index">The current index</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.NextVertex(System.Int32)">
            <summary>
            Gets the next vertex. Used for iterating all the edges with wrap-around.
            </summary>
            <param name="index">The current index</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.PreviousIndex(System.Int32)">
            <summary>
            Gets the previous index. Used for iterating all the edges with wrap-around.
            </summary>
            <param name="index">The current index</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.PreviousVertex(System.Int32)">
            <summary>
            Gets the previous vertex. Used for iterating all the edges with wrap-around.
            </summary>
            <param name="index">The current index</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.GetSignedArea">
            <summary>
            Gets the signed area.
            If the area is less than 0, it indicates that the polygon is clockwise winded.
            </summary>
            <returns>The signed area</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.GetArea">
            <summary>
            Gets the area.
            </summary>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.GetCentroid">
            <summary>
            Gets the centroid.
            </summary>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.GetAABB">
            <summary>
            Returns an AABB that fully contains this polygon.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.Translate(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Translates the vertices with the specified vector.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.Translate(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Translates the vertices with the specified vector.
            </summary>
            <param name="value">The vector.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.Scale(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Scales the vertices with the specified vector.
            </summary>
            <param name="value">The Value.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.Scale(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Scales the vertices with the specified vector.
            </summary>
            <param name="value">The Value.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.Rotate(System.Single)">
            <summary>
            Rotate the vertices with the defined value in radians.
            
            Warning: Using this method on an active set of vertices of a Body,
            will cause problems with collisions. Use Body.Rotation instead.
            </summary>
            <param name="value">The amount to rotate by in radians.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.IsConvex">
            <summary>
            Determines whether the polygon is convex.
            O(n^2) running time.
            
            Assumptions:
            - The polygon is in counter clockwise order
            - The polygon has no overlapping edges
            </summary>
            <returns>
            	<c>true</c> if it is convex; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.IsCounterClockWise">
            <summary>
            Indicates if the vertices are in counter clockwise order.
            Warning: If the area of the polygon is 0, it is unable to determine the winding.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.ForceCounterClockWise">
            <summary>
            Forces the vertices to be counter clock wise order.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.IsSimple">
            <summary>
            Checks if the vertices forms an simple polygon by checking for edge crossings.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.CheckPolygon">
             <summary>
             Checks if the polygon is valid for use in the engine.
            
             Performs a full check, for simplicity, convexity,
             orientation, minimum angle, and volume.
             
             From Eric Jordan's convex decomposition library
             </summary>
             <returns>PolygonError.NoError if there were no error.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.ProjectToAxis(Microsoft.Xna.Framework.Vector2@,System.Single@,System.Single@)">
            <summary>
            Projects to axis.
            </summary>
            <param name="axis">The axis.</param>
            <param name="min">The min.</param>
            <param name="max">The max.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.PointInPolygon(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Winding number test for a point in a polygon.
            </summary>
            See more info about the algorithm here: http://softsurfer.com/Archive/algorithm_0103/algorithm_0103.htm
            <param name="point">The point to be tested.</param>
            <returns>-1 if the winding number is zero and the point is outside
            the polygon, 1 if the point is inside the polygon, and 0 if the point
            is on the polygons edge.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.PointInPolygonAngle(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Compute the sum of the angles made between the test point and each pair of points making up the polygon. 
            If this sum is 2pi then the point is an interior point, if 0 then the point is an exterior point. 
            ref: http://ozviz.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/  - Solution 2 
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Common.Vertices.Transform(Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Transforms the polygon using the defined matrix.
            </summary>
            <param name="transform">The matrix to use as transformation.</param>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Controllers.AbstractForceController.DecayModes">
            <summary>
            Modes for Decay. Actual Decay must be implemented in inheriting 
            classes
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Controllers.AbstractForceController.ForceTypes">
            <summary>
            Forcetypes are used in the decay math to properly get the distance.
            They are also used to draw a representation in DebugView
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Controllers.AbstractForceController.TimingModes">
            <summary>
            Timing Modes
            Switched: Standard on/off mode using the baseclass enabled property
            Triggered: When the Trigger() method is called the force is active 
            for a specified Impulse Length
            Curve: Still to be defined. The basic idea is having a Trigger 
            combined with a curve for the strength
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Controllers.AbstractForceController.DecayCurve">
            <summary>
            Curve to be used for Decay in Curve mode
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Controllers.AbstractForceController.ForceType">
            <summary>
            The Forcetype of the instance
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Controllers.AbstractForceController.Randomize">
            <summary>
            Provided for reuse to provide Variation functionality in 
            inheriting classes
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Controllers.AbstractForceController.StrengthCurve">
            <summary>
            Curve used by Curve Mode as an animated multiplier for the force 
            strength.
            Only positions between 0 and 1 are considered as that range is 
            stretched to have ImpulseLength.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Controllers.AbstractForceController.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Controllers.AbstractForceController.#ctor(tainicom.Aether.Physics2D.Controllers.AbstractForceController.TimingModes)">
            <summary>
            Overloaded Contstructor with supplying Timing Mode
            </summary>
            <param name="mode"></param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Controllers.AbstractForceController.Strength">
            <summary>
            Global Strength of the force to be applied
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Controllers.AbstractForceController.Position">
            <summary>
            Position of the Force. Can be ignored (left at (0,0) for forces
            that are not position-dependent
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Controllers.AbstractForceController.MaximumSpeed">
            <summary>
            Maximum speed of the bodies. Bodies that are travelling faster are
            supposed to be ignored
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Controllers.AbstractForceController.MaximumForce">
            <summary>
            Maximum Force to be applied. As opposed to Maximum Speed this is 
            independent of the velocity of
            the affected body
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Controllers.AbstractForceController.TimingMode">
            <summary>
            Timing Mode of the force instance
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Controllers.AbstractForceController.ImpulseTime">
            <summary>
            Time of the current impulse. Incremented in update till 
            ImpulseLength is reached
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Controllers.AbstractForceController.ImpulseLength">
            <summary>
            Length of a triggered impulse. Used in both Triggered and Curve Mode
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Controllers.AbstractForceController.Triggered">
            <summary>
            Indicating if we are currently during an Impulse 
            (Triggered and Curve Mode)
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Controllers.AbstractForceController.Variation">
            <summary>
            Variation of the force applied to each body affected
            !! Must be used in inheriting classes properly !!
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Controllers.AbstractForceController.DecayMode">
            <summary>
            See DecayModes
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Controllers.AbstractForceController.DecayStart">
            <summary>
            Start of the distance based Decay. To set a non decaying area
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Controllers.AbstractForceController.DecayEnd">
            <summary>
            Maximum distance a force should be applied
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Controllers.AbstractForceController.GetDecayMultiplier(tainicom.Aether.Physics2D.Dynamics.Body)">
            <summary>
            Calculate the Decay for a given body. Meant to ease force 
            development and stick to the DRY principle and provide unified and 
            predictable decay math.
            </summary>
            <param name="body">The body to calculate decay for</param>
            <returns>A multiplier to multiply the force with to add decay 
            support in inheriting classes</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Controllers.AbstractForceController.Trigger">
            <summary>
            Triggers the trigger modes (Trigger and Curve)
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Controllers.AbstractForceController.Update(System.Single)">
            <summary>
            Inherited from Controller
            Depending on the TimingMode perform timing logic and call ApplyForce()
            </summary>
            <param name="dt"></param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Controllers.AbstractForceController.ApplyForce(System.Single,System.Single)">
            <summary>
            Apply the force supplying strength (wich is modified in Update() 
            according to the TimingMode
            </summary>
            <param name="dt"></param>
            <param name="strength">The strength</param>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Controllers.BuoyancyController.AngularDragCoefficient">
            <summary>
            Controls the rotational drag that the fluid exerts on the bodies within it. Use higher values will simulate thick fluid, like honey, lower values to
            simulate water-like fluids. 
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Controllers.BuoyancyController.Density">
            <summary>
            Density of the fluid. Higher values will make things more buoyant, lower values will cause things to sink.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Controllers.BuoyancyController.LinearDragCoefficient">
            <summary>
            Controls the linear drag that the fluid exerts on the bodies within it.  Use higher values will simulate thick fluid, like honey, lower values to
            simulate water-like fluids.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Controllers.BuoyancyController.Velocity">
            <summary>
            Acts like waterflow. Defaults to 0,0.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Controllers.BuoyancyController.#ctor(tainicom.Aether.Physics2D.Collision.AABB,System.Single,System.Single,System.Single,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Initializes a new instance of the <see cref="T:tainicom.Aether.Physics2D.Controllers.BuoyancyController"/> class.
            </summary>
            <param name="container">Only bodies inside this AABB will be influenced by the controller</param>
            <param name="density">Density of the fluid</param>
            <param name="linearDragCoefficient">Linear drag coefficient of the fluid</param>
            <param name="rotationalDragCoefficient">Rotational drag coefficient of the fluid</param>
            <param name="gravity">The direction gravity acts. Buoyancy force will act in opposite direction of gravity.</param>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Controllers.SimpleWindForce">
            <summary>
            Reference implementation for forces based on AbstractForceController
            It supports all features provided by the base class and illustrates proper
            usage as an easy to understand example.
            As a side-effect it is a nice and easy to use wind force for your projects
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Controllers.SimpleWindForce.Direction">
            <summary>
            Direction of the windforce
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Controllers.SimpleWindForce.Divergence">
            <summary>
            The amount of Direction randomization. Allowed range is 0-1.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Controllers.SimpleWindForce.IgnorePosition">
            <summary>
            Ignore the position and apply the force. If off only in the "front" (relative to position and direction)
            will be affected
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Controllers.VelocityLimitController">
            <summary>
            Put a limit on the linear (translation - the movespeed) and angular (rotation) velocity
            of bodies added to this controller.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Controllers.VelocityLimitController.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:tainicom.Aether.Physics2D.Controllers.VelocityLimitController"/> class.
            Sets the max linear velocity to Settings.MaxTranslation
            Sets the max angular velocity to Settings.MaxRotation
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Controllers.VelocityLimitController.#ctor(System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:tainicom.Aether.Physics2D.Controllers.VelocityLimitController"/> class.
            Pass in 0 or float.MaxValue to disable the limit.
            maxAngularVelocity = 0 will disable the angular velocity limit.
            </summary>
            <param name="maxLinearVelocity">The max linear velocity.</param>
            <param name="maxAngularVelocity">The max angular velocity.</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Controllers.VelocityLimitController.MaxAngularVelocity">
            <summary>
            Gets or sets the max angular velocity.
            </summary>
            <value>The max angular velocity.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Controllers.VelocityLimitController.MaxLinearVelocity">
            <summary>
            Gets or sets the max linear velocity.
            </summary>
            <value>The max linear velocity.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.World">
            <summary>
            Get the parent World of this body. This is null if the body is not attached.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.IslandIndex">
            <remarks>Deprecated in version 1.6</remarks>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.Body.Tag">
            <summary>
            Set the user data. Use this to store your application specific data.
            </summary>
            <value>The user data.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.Revolutions">
            <summary>
            Gets the total number revolutions the body has made.
            </summary>
            <value>The revolutions.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.BodyType">
            <summary>
            Gets or sets the body type.
            Warning: This property is readonly during callbacks.
            </summary>
            <value>The type of body.</value>
            <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.LinearVelocity">
            <summary>
            Get or sets the linear velocity of the center of mass. Property has no effect on <see cref="F:tainicom.Aether.Physics2D.Dynamics.BodyType.Static"/> bodies.
            </summary>
            <value>The linear velocity.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.AngularVelocity">
            <summary>
            Gets or sets the angular velocity. Radians/second.
            </summary>
            <value>The angular velocity.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.LinearDamping">
            <summary>
            Gets or sets the linear damping.
            </summary>
            <value>The linear damping.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.AngularDamping">
            <summary>
            Gets or sets the angular damping.
            </summary>
            <value>The angular damping.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.IsBullet">
            <summary>
            Gets or sets a value indicating whether this body should be included in the CCD solver.
            </summary>
            <value><c>true</c> if this instance is included in CCD; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.SleepingAllowed">
            <summary>
            You can disable sleeping on this body. If you disable sleeping, the
            body will be woken.
            </summary>
            <value><c>true</c> if sleeping is allowed; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.Awake">
            <summary>
            Set the sleep state of the body. A sleeping body has very
            low CPU cost.
            </summary>
            <value><c>true</c> if awake; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.Enabled">
            <summary>
            Set the active state of the body. An inactive body is not
            simulated and cannot be collided with or woken up.
            If you pass a flag of true, all fixtures will be added to the
            broad-phase.
            If you pass a flag of false, all fixtures will be removed from
            the broad-phase and all contacts will be destroyed.
            Fixtures and joints are otherwise unaffected. You may continue
            to create/destroy fixtures and joints on inactive bodies.
            Fixtures on an inactive body are implicitly inactive and will
            not participate in collisions, ray-casts, or queries.
            Joints connected to an inactive body are implicitly inactive.
            An inactive body is still owned by a b2World object and remains
            in the body list.
            Warning: This property is readonly during callbacks.
            </summary>
            <value><c>true</c> if active; otherwise, <c>false</c>.</value>
            <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.CreateProxies">
            <summary>
            Create all proxies.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.DestroyProxies">
            <summary>
            Destroy all proxies.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.DestroyContacts">
            <summary>
            Destroy the attached contacts.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.FixedRotation">
            <summary>
            Set this body to have fixed rotation. This causes the mass
            to be reset.
            </summary>
            <value><c>true</c> if it has fixed rotation; otherwise, <c>false</c>.</value>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.Body.FixtureList">
            <summary>
            Gets all the fixtures attached to this body.
            </summary>
            <value>The fixture list.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.JointList">
            <summary>
            Get the list of all joints attached to this body.
            </summary>
            <value>The joint list.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.ContactList">
            <summary>
            Get the list of all contacts attached to this body.
            Warning: this list changes during the time step and you may
            miss some collisions if you don't use callback events.
            </summary>
            <value>The contact list.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.Position">
            <summary>
            Get the world body origin position.
            </summary>
            <returns>Return the world position of the body's origin.</returns>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.Rotation">
            <summary>
            Get the angle in radians.
            </summary>
            <returns>Return the current world rotation angle in radians.</returns>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.IgnoreGravity">
            <summary>
            Gets or sets a value indicating whether this body ignores gravity.
            </summary>
            <value><c>true</c> if  it ignores gravity; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.WorldCenter">
            <summary>
            Get the world position of the center of mass.
            </summary>
            <value>The world position.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.LocalCenter">
            <summary>
            Get the local position of the center of mass.
            Warning: This property is readonly during callbacks.
            </summary>
            <value>The local position.</value>
            <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.Mass">
            <summary>
            Gets or sets the mass. Usually in kilograms (kg).
            Warning: This property is readonly during callbacks.
            </summary>
            <value>The mass.</value>
            <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Body.Inertia">
            <summary>
            Get or set the rotational inertia of the body about the local origin. usually in kg-m^2.
            Warning: This property is readonly during callbacks.
            </summary>
            <value>The inertia.</value>
            <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.ResetDynamics">
            <summary>
            Resets the dynamics of this body.
            Sets torque, force and linear/angular velocity to 0
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.Add(tainicom.Aether.Physics2D.Dynamics.Fixture)">
            <summary>
             Warning: This method is locked during callbacks.
             </summary>>
             <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.Remove(tainicom.Aether.Physics2D.Dynamics.Fixture)">
            <summary>
            Destroy a fixture. This removes the fixture from the broad-phase and
            destroys all contacts associated with this fixture. This will
            automatically adjust the mass of the body if the body is dynamic and the
            fixture has positive density.
            All fixtures attached to a body are implicitly destroyed when the body is destroyed.
            Warning: This method is locked during callbacks.
            </summary>
            <param name="fixture">The fixture to be removed.</param>
            <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.SetTransform(Microsoft.Xna.Framework.Vector2@,System.Single)">
            <summary>
            Set the position of the body's origin and rotation.
            This breaks any contacts and wakes the other bodies.
            Manipulating a body's transform may cause non-physical behavior.
            Warning: This method is locked during callbacks.
            </summary>
            <param name="position">The world position of the body's local origin.</param>
            <param name="rotation">The world rotation in radians.</param>
            <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.SetTransform(Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            Set the position of the body's origin and rotation.
            This breaks any contacts and wakes the other bodies.
            Manipulating a body's transform may cause non-physical behavior.
            Warning: This method is locked during callbacks.
            </summary>
            <param name="position">The world position of the body's local origin.</param>
            <param name="rotation">The world rotation in radians.</param>
            <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.SetTransformIgnoreContacts(Microsoft.Xna.Framework.Vector2@,System.Single)">
            <summary>
            For teleporting a body without considering new contacts immediately.
            Warning: This method is locked during callbacks.
            </summary>
            <param name="position">The position.</param>
            <param name="angle">The angle.</param>
            <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.GetTransform">
            <summary>
            Get the body transform for the body's origin.
            </summary>
            <param name="transform">The transform of the body's origin.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.GetTransform(tainicom.Aether.Physics2D.Common.Transform@)">
            <summary>
            Get the body transform for the body's origin.
            </summary>
            <param name="transform">The transform of the body's origin.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.ApplyForce(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Apply a force at a world point. If the force is not
            applied at the center of mass, it will generate a torque and
            affect the angular velocity. This wakes up the body.
            </summary>
            <param name="force">The world force vector, usually in Newtons (N).</param>
            <param name="point">The world position of the point of application.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.ApplyForce(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Applies a force at the center of mass.
            </summary>
            <param name="force">The force.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.ApplyForce(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Applies a force at the center of mass.
            </summary>
            <param name="force">The force.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.ApplyForce(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Apply a force at a world point. If the force is not
            applied at the center of mass, it will generate a torque and
            affect the angular velocity. This wakes up the body.
            </summary>
            <param name="force">The world force vector, usually in Newtons (N).</param>
            <param name="point">The world position of the point of application.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.ApplyTorque(System.Single)">
            <summary>
            Apply a torque. This affects the angular velocity
            without affecting the linear velocity of the center of mass.
            This wakes up the body.
            </summary>
            <param name="torque">The torque about the z-axis (out of the screen), usually in N-m.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.ApplyLinearImpulse(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Apply an impulse at a point. This immediately modifies the velocity.
            This wakes up the body.
            </summary>
            <param name="impulse">The world impulse vector, usually in N-seconds or kg-m/s.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.ApplyLinearImpulse(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Apply an impulse at a point. This immediately modifies the velocity.
            It also modifies the angular velocity if the point of application
            is not at the center of mass.
            This wakes up the body.
            </summary>
            <param name="impulse">The world impulse vector, usually in N-seconds or kg-m/s.</param>
            <param name="point">The world position of the point of application.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.ApplyLinearImpulse(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Apply an impulse at a point. This immediately modifies the velocity.
            This wakes up the body.
            </summary>
            <param name="impulse">The world impulse vector, usually in N-seconds or kg-m/s.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.ApplyLinearImpulse(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Apply an impulse at a point. This immediately modifies the velocity.
            It also modifies the angular velocity if the point of application
            is not at the center of mass.
            This wakes up the body.
            </summary>
            <param name="impulse">The world impulse vector, usually in N-seconds or kg-m/s.</param>
            <param name="point">The world position of the point of application.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.ApplyAngularImpulse(System.Single)">
            <summary>
            Apply an angular impulse.
            </summary>
            <param name="impulse">The angular impulse in units of kg*m*m/s.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.ResetMassData">
            <summary>
            This resets the mass properties to the sum of the mass properties of the fixtures.
            This normally does not need to be called unless you called SetMassData to override
            the mass and you later want to reset the mass.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.GetWorldPoint(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Get the world coordinates of a point given the local coordinates.
            </summary>
            <param name="localPoint">A point on the body measured relative the the body's origin.</param>
            <returns>The same point expressed in world coordinates.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.GetWorldPoint(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Get the world coordinates of a point given the local coordinates.
            </summary>
            <param name="localPoint">A point on the body measured relative the the body's origin.</param>
            <returns>The same point expressed in world coordinates.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.GetWorldVector(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Get the world coordinates of a vector given the local coordinates.
            Note that the vector only takes the rotation into account, not the position.
            </summary>
            <param name="localVector">A vector fixed in the body.</param>
            <returns>The same vector expressed in world coordinates.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.GetWorldVector(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Get the world coordinates of a vector given the local coordinates.
            </summary>
            <param name="localVector">A vector fixed in the body.</param>
            <returns>The same vector expressed in world coordinates.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.GetLocalPoint(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Gets a local point relative to the body's origin given a world point.
            Note that the vector only takes the rotation into account, not the position.
            </summary>
            <param name="worldPoint">A point in world coordinates.</param>
            <returns>The corresponding local point relative to the body's origin.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.GetLocalPoint(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Gets a local point relative to the body's origin given a world point.
            </summary>
            <param name="worldPoint">A point in world coordinates.</param>
            <returns>The corresponding local point relative to the body's origin.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.GetLocalVector(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Gets a local vector given a world vector.
            Note that the vector only takes the rotation into account, not the position.
            </summary>
            <param name="worldVector">A vector in world coordinates.</param>
            <returns>The corresponding local vector.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.GetLocalVector(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Gets a local vector given a world vector.
            Note that the vector only takes the rotation into account, not the position.
            </summary>
            <param name="worldVector">A vector in world coordinates.</param>
            <returns>The corresponding local vector.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.GetLinearVelocityFromWorldPoint(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Get the world linear velocity of a world point attached to this body.
            </summary>
            <param name="worldPoint">A point in world coordinates.</param>
            <returns>The world velocity of a point.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.GetLinearVelocityFromWorldPoint(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Get the world linear velocity of a world point attached to this body.
            </summary>
            <param name="worldPoint">A point in world coordinates.</param>
            <returns>The world velocity of a point.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.GetLinearVelocityFromLocalPoint(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Get the world velocity of a local point.
            </summary>
            <param name="localPoint">A point in local coordinates.</param>
            <returns>The world velocity of a point.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.GetLinearVelocityFromLocalPoint(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Get the world velocity of a local point.
            </summary>
            <param name="localPoint">A point in local coordinates.</param>
            <returns>The world velocity of a point.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.ShouldCollide(tainicom.Aether.Physics2D.Dynamics.Body)">
            <summary>
            This is used to prevent connected bodies from colliding.
            It may lie, depending on the collideConnected flag.
            </summary>
            <param name="other">The other body.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.SetRestitution(System.Single)">
            <summary>
            Set restitution on all fixtures.
            Warning: This method applies the value on existing Fixtures. It's not a property of Body.
            </summary>
            <param name="restitution"></param>
            <remarks>Deprecated in version 1.6</remarks>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.SetFriction(System.Single)">
            <summary>
            Set friction on all fixtures.
            Warning: This method applies the value on existing Fixtures. It's not a property of Body.
            </summary>
            <param name="friction"></param>
            <remarks>Deprecated in version 1.6</remarks>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.SetCollisionCategories(tainicom.Aether.Physics2D.Dynamics.Category)">
            <summary>
            Warning: This method applies the value on existing Fixtures. It's not a property of Body.
            </summary>
            <remarks>Deprecated in version 1.6</remarks>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.SetCollidesWith(tainicom.Aether.Physics2D.Dynamics.Category)">
            <summary>
            Warning: This method applies the value on existing Fixtures. It's not a property of Body.
            </summary>
            <remarks>Deprecated in version 1.6</remarks>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.SetCollisionGroup(System.Int16)">
            <summary>
            Warning: This method applies the value on existing Fixtures. It's not a property of Body.
            </summary>
            <remarks>Deprecated in version 1.6</remarks>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.SetIsSensor(System.Boolean)">
            <summary>
            Warning: This method applies the value on existing Fixtures. It's not a property of Body.
            </summary>
            <remarks>Deprecated in version 1.6</remarks>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.Clone(tainicom.Aether.Physics2D.Dynamics.World)">
            <summary>
            Makes a clone of the body. Fixtures and therefore shapes are not included.
            Use DeepClone() to clone the body, as well as fixtures and shapes.
            </summary>
            <param name="world"></param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.DeepClone(tainicom.Aether.Physics2D.Dynamics.World)">
            <summary>
            Clones the body and all attached fixtures and shapes. Simply said, it makes a complete copy of the body.
            </summary>
            <param name="world"></param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Body.CreateFixture(tainicom.Aether.Physics2D.Collision.Shapes.Shape)">
            <summary>
            Creates a fixture and attach it to this body.
            If the density is non-zero, this function automatically updates the mass of the body.
            Contacts are not created until the next time step.
            Warning: This method is locked during callbacks.
            </summary>
            <param name="shape">The shape.</param>
            <param name="userData">Application specific data</param>
            <returns></returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.BodyType">
            <summary>
            The body type.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.BodyType.Static">
            <summary>
            Zero velocity, may be manually moved. Note: even static bodies have mass.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.BodyType.Kinematic">
            <summary>
            Zero mass, non-zero velocity set by user, moved by solver
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.BodyType.Dynamic">
            <summary>
            Positive mass, non-zero velocity determined by forces, moved by solver
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.ContactManager.VelocityConstraintsMultithreadThreshold">
            <summary>
            A threshold for activating multiple cores to solve VelocityConstraints.
            An Island with a contact count above this threshold will use multiple threads to solve VelocityConstraints.
            A value of 0 will always use multithreading. A value of (int.MaxValue) will never use multithreading.
            Typical values are {128 or 256}.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.ContactManager.PositionConstraintsMultithreadThreshold">
            <summary>
            A threshold for activating multiple cores to solve PositionConstraints.
            An Island with a contact count above this threshold will use multiple threads to solve PositionConstraints.
            A value of 0 will always use multithreading. A value of (int.MaxValue) will never use multithreading.
            Typical values are {128 or 256}.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.ContactManager.CollideMultithreadThreshold">
            <summary>
            A threshold for activating multiple cores to solve Collide.
            An World with a contact count above this threshold will use multiple threads to solve Collide.
            A value of 0 will always use multithreading. A value of (int.MaxValue) will never use multithreading.
            Typical values are {128 or 256}.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.ContactManager.BeginContact">
            <summary>
            Fires when a contact is created
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.ContactManager.ContactFilter">
            <summary>
            The filter used by the contact manager.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.ContactManager.EndContact">
            <summary>
            Fires when a contact is deleted
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.ContactManager.OnBroadphaseCollision">
            <summary>
            Fires when the broadphase detects that two Fixtures are close to each other.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.ContactManager.PostSolve">
            <summary>
            Fires after the solver has run
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.ContactManager.PreSolve">
            <summary>
            Fires before the solver runs
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.ContactManager.updateList">
            <summary>
            A temporary list of contacts to be updated during Collide().
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Contacts.ContactEdge">
            <summary>
            A contact edge is used to connect bodies and contacts together
            in a contact graph where each body is a node and each contact
            is an edge. A contact edge belongs to a doubly linked list
            maintained in each attached body. Each contact has two contact
            nodes, one for each attached body.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Contacts.ContactEdge.Contact">
            <summary>
            The contact
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Contacts.ContactEdge.Other">
            <summary>
            Provides quick access to the other body attached.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Contacts.ContactEdge.Next">
            <summary>
            The next contact edge in the body's contact list
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Contacts.ContactEdge.Prev">
            <summary>
            The previous contact edge in the body's contact list
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Contacts.Contact">
            <summary>
            The class manages contact between two shapes. A contact exists for each overlapping
            AABB in the broad-phase (except if filtered). Therefore a contact object may exist
            that has no contact points.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.Contacts.Contact.Manifold">
            <summary>
            Get the contact manifold. Do not modify the manifold unless you understand the
            internals of Box2D.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Contacts.Contact.TangentSpeed">
            Get or set the desired tangent speed for a conveyor belt behavior. In meters per second.
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Contacts.Contact.Enabled">
            Enable/disable this contact. This can be used inside the pre-solve
            contact listener. The contact is only disabled for the current
            time step (or sub-step in continuous collisions).
            NOTE: If you are setting Enabled to a constant true or false,
            use the explicit Enable() or Disable() functions instead to 
            save the CPU from doing a branch operation.
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Contacts.Contact.ChildIndexA">
            <summary>
            Get the child primitive index for fixture A.
            </summary>
            <value>The child index A.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Contacts.Contact.ChildIndexB">
            <summary>
            Get the child primitive index for fixture B.
            </summary>
            <value>The child index B.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Contacts.Contact.Next">
            <summary>
            Get the next contact in the world's contact list.
            </summary>
            <value>The next.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Contacts.Contact.Prev">
            <summary>
            Get the previous contact in the world's contact list.
            </summary>
            <value>The prev.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Contacts.Contact.IsTouching">
            <summary>
            Determines whether this contact is touching.
            </summary>
            <returns>
            	<c>true</c> if this instance is touching; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Contacts.Contact.GetWorldManifold(Microsoft.Xna.Framework.Vector2@,tainicom.Aether.Physics2D.Common.FixedArray2{Microsoft.Xna.Framework.Vector2}@)">
            <summary>
            Gets the world manifold.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Contacts.Contact.Update(tainicom.Aether.Physics2D.Dynamics.ContactManager)">
            <summary>
            Update the contact manifold and touching status.
            Note: do not assume the fixture AABBs are overlapping or are valid.
            </summary>
            <param name="contactManager">The contact manager.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Contacts.Contact.Evaluate(tainicom.Aether.Physics2D.Collision.Manifold@,tainicom.Aether.Physics2D.Common.Transform@,tainicom.Aether.Physics2D.Common.Transform@)">
            <summary>
            Evaluate this contact with your own manifold and transforms.   
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="transformA">The first transform.</param>
            <param name="transformB">The second transform.</param>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Contacts.ContactListHead">
            <summary>
            Head of a circular doubly linked list.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Contacts.ContactSolver.WorldManifold.Initialize(tainicom.Aether.Physics2D.Collision.Manifold@,tainicom.Aether.Physics2D.Common.Transform@,System.Single,tainicom.Aether.Physics2D.Common.Transform@,System.Single,Microsoft.Xna.Framework.Vector2@,tainicom.Aether.Physics2D.Common.FixedArray2{Microsoft.Xna.Framework.Vector2}@)">
            <summary>
            Evaluate the manifold with supplied transforms. This assumes
            modest motion from the original state. This does not change the
            point count, impulses, etc. The radii must come from the Shapes
            that generated the manifold.
            </summary>
            <param name="manifold">The manifold.</param>
            <param name="xfA">The transform for A.</param>
            <param name="radiusA">The radius for A.</param>
            <param name="xfB">The transform for B.</param>
            <param name="radiusB">The radius for B.</param>
            <param name="normal">World vector pointing from A to B</param>
            <param name="points">Torld contact point (point of intersection).</param>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Fixture">
            <summary>
            A fixture is used to attach a Shape to a body for collision detection. A fixture
            inherits its transform from its parent. Fixtures hold additional non-geometric data
            such as friction, collision filters, etc.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.Fixture.AfterCollision">
            <summary>
            Fires after two shapes has collided and are solved. This gives you a chance to get the impact force.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.Fixture.BeforeCollision">
            <summary>
            Fires when two fixtures are close to each other.
            Due to how the broadphase works, this can be quite inaccurate as shapes are approximated using AABBs.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.Fixture.OnCollision">
            <summary>
            Fires when two shapes collide and a contact is created between them.
            Note that the first fixture argument is always the fixture that the delegate is subscribed to.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.Fixture.OnSeparation">
            <summary>
            Fires when two shapes separate and a contact is removed between them.
            Note: This can in some cases be called multiple times, as a fixture can have multiple contacts.
            Note The first fixture argument is always the fixture that the delegate is subscribed to.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Fixture.CollisionGroup">
            <summary>
            Defaults to 0
            
            Collision groups allow a certain group of objects to never collide (negative)
            or always collide (positive). Zero means no collision group. Non-zero group
            filtering always wins against the mask bits.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Fixture.CollidesWith">
            <summary>
            Defaults to Category.All
            
            The collision mask bits. This states the categories that this
            fixture would accept for collision.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Fixture.CollisionCategories">
            <summary>
            The collision categories this fixture is a part of.
            
            Defaults to Category.Cat1
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Fixture.Shape">
            <summary>
            Get the child Shape.
            </summary>
            <value>The shape.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Fixture.IsSensor">
            <summary>
            Gets or sets a value indicating whether this fixture is a sensor.
            </summary>
            <value><c>true</c> if this instance is a sensor; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Fixture.Body">
            <summary>
            Get the parent body of this fixture. This is null if the fixture is not attached.
            </summary>
            <value>The body.</value>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.Fixture.Tag">
            <summary>
            Set the user data. Use this to store your application specific data.
            </summary>
            <value>The user data.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Fixture.Friction">
            <summary>
            Set the coefficient of friction. This will _not_ change the friction of
            existing contacts.
            </summary>
            <value>The friction.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Fixture.Restitution">
            <summary>
            Set the coefficient of restitution. This will not change the restitution of
            existing contacts.
            </summary>
            <value>The restitution.</value>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Fixture.Refilter">
            <summary>
            Contacts are persistant and will keep being persistant unless they are
            flagged for filtering.
            This methods flags all contacts associated with the body for filtering.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Fixture.TouchProxies(tainicom.Aether.Physics2D.Collision.IBroadPhase)">
            <summary>
            Touch each proxy so that new pairs may be created
            </summary>
            <param name="broadPhase"></param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Fixture.TestPoint(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Test a point for containment in this fixture.
            </summary>
            <param name="point">A point in world coordinates.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Fixture.RayCast(tainicom.Aether.Physics2D.Collision.RayCastOutput@,tainicom.Aether.Physics2D.Collision.RayCastInput@,System.Int32)">
            <summary>
            Cast a ray against this Shape.
            </summary>
            <param name="output">The ray-cast results.</param>
            <param name="input">The ray-cast input parameters.</param>
            <param name="childIndex">Index of the child.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Fixture.GetAABB(tainicom.Aether.Physics2D.Collision.AABB@,System.Int32)">
            <summary>
            Get the fixture's AABB. This AABB may be enlarge and/or stale.
            If you need a more accurate AABB, compute it using the Shape and
            the body transform.
            </summary>
            <param name="aabb">The aabb.</param>
            <param name="childIndex">Index of the child.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Fixture.CloneOnto(tainicom.Aether.Physics2D.Dynamics.Body)">
            <summary>
            Clones the fixture onto the specified body.
            </summary>
            <param name="body">The body you wish to clone the fixture onto.</param>
            <returns>The cloned fixture.</returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Fixture.CloneOnto(tainicom.Aether.Physics2D.Dynamics.Body,tainicom.Aether.Physics2D.Collision.Shapes.Shape)">
            <summary>
            Clones the fixture and attached shape onto the specified body.
            Note: This is used only by Deserialization.
            </summary>
            <param name="body">The body you wish to clone the fixture onto.</param>
            <returns>The cloned fixture.</returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.FixtureProxy">
            <summary>
            This proxy is used internally to connect fixtures to the broad-phase.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Island">
            <summary>
            This is an internal class.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Joints.AngleJoint">
            <summary>
            Maintains a fixed angle between two bodies
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.AngleJoint.#ctor(tainicom.Aether.Physics2D.Dynamics.Body,tainicom.Aether.Physics2D.Dynamics.Body)">
            <summary>
            Constructor for AngleJoint
            </summary>
            <param name="bodyA">The first body</param>
            <param name="bodyB">The second body</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.AngleJoint.TargetAngle">
            <summary>
            The desired angle between BodyA and BodyB
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.AngleJoint.BiasFactor">
            <summary>
            Gets or sets the bias factor.
            Defaults to 0.2
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.AngleJoint.MaxImpulse">
            <summary>
            Gets or sets the maximum impulse
            Defaults to float.MaxValue
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.AngleJoint.Softness">
            <summary>
            Gets or sets the softness of the joint
            Defaults to 0
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Joints.DistanceJoint">
            <summary>
            A distance joint rains two points on two bodies
            to remain at a fixed distance from each other. You can view
            this as a massless, rigid rod.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.DistanceJoint.#ctor(tainicom.Aether.Physics2D.Dynamics.Body,tainicom.Aether.Physics2D.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Boolean)">
            <summary>
            This requires defining an
            anchor point on both bodies and the non-zero length of the
            distance joint. If you don't supply a length, the local anchor points
            is used so that the initial configuration can violate the constraint
            slightly. This helps when saving and loading a game.
            Warning Do not use a zero or short length.
            </summary>
            <param name="bodyA">The first body</param>
            <param name="bodyB">The second body</param>
            <param name="anchorA">The first body anchor</param>
            <param name="anchorB">The second body anchor</param>
            <param name="useWorldCoordinates">Set to true if you are using world coordinates as anchors.</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.DistanceJoint.LocalAnchorA">
            <summary>
            The local anchor point relative to bodyA's origin.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.DistanceJoint.LocalAnchorB">
            <summary>
            The local anchor point relative to bodyB's origin.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.DistanceJoint.Length">
            <summary>
            The natural length between the anchor points.
            Manipulating the length can lead to non-physical behavior when the frequency is zero.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.DistanceJoint.Frequency">
            <summary>
            The mass-spring-damper frequency in Hertz. A value of 0
            disables softness.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.DistanceJoint.DampingRatio">
            <summary>
            The damping ratio. 0 = no damping, 1 = critical damping.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.DistanceJoint.GetReactionForce(System.Single)">
            <summary>
            Get the reaction force given the inverse time step. Unit is N.
            </summary>
            <param name="invDt"></param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.DistanceJoint.GetReactionTorque(System.Single)">
            <summary>
            Get the reaction torque given the inverse time step.
            Unit is N*m. This is always zero for a distance joint.
            </summary>
            <param name="invDt"></param>
            <returns></returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Joints.FixedMouseJoint">
            <summary>
            A mouse joint is used to make a point on a body track a
            specified world point. This a soft constraint with a maximum
            force. This allows the constraint to stretch and without
            applying huge forces.
            NOTE: this joint is not documented in the manual because it was
            developed to be used in the testbed. If you want to learn how to
            use the mouse joint, look at the testbed.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.FixedMouseJoint.#ctor(tainicom.Aether.Physics2D.Dynamics.Body,Microsoft.Xna.Framework.Vector2)">
            <summary>
            This requires a world target point,
            tuning parameters, and the time step.
            </summary>
            <param name="body">The body.</param>
            <param name="worldAnchor">The target.</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.FixedMouseJoint.LocalAnchorA">
            <summary>
            The local anchor point on BodyA
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.FixedMouseJoint.MaxForce">
            <summary>
            The maximum constraint force that can be exerted
            to move the candidate body. Usually you will express
            as some multiple of the weight (multiplier * mass * gravity).
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.FixedMouseJoint.Frequency">
            <summary>
            The response speed.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.FixedMouseJoint.DampingRatio">
            <summary>
            The damping ratio. 0 = no damping, 1 = critical damping.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Joints.FrictionJoint">
            <summary>
            Friction joint. This is used for top-down friction.
            It provides 2D translational friction and angular friction.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.FrictionJoint.#ctor(tainicom.Aether.Physics2D.Dynamics.Body,tainicom.Aether.Physics2D.Dynamics.Body,Microsoft.Xna.Framework.Vector2,System.Boolean)">
            <summary>
            Constructor for FrictionJoint.
            </summary>
            <param name="bodyA"></param>
            <param name="bodyB"></param>
            <param name="anchor"></param>
            <param name="useWorldCoordinates">Set to true if you are using world coordinates as anchors.</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.FrictionJoint.LocalAnchorA">
            <summary>
            The local anchor point on BodyA
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.FrictionJoint.LocalAnchorB">
            <summary>
            The local anchor point on BodyB
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.FrictionJoint.MaxForce">
            <summary>
            The maximum friction force in N.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.FrictionJoint.MaxTorque">
            <summary>
            The maximum friction torque in N-m.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Joints.GearJoint">
             <summary>
             A gear joint is used to connect two joints together.
             Either joint can be a revolute or prismatic joint.
             You specify a gear ratio to bind the motions together:
             <![CDATA[coordinate1 + ratio * coordinate2 = ant]]>
             The ratio can be negative or positive. If one joint is a revolute joint
             and the other joint is a prismatic joint, then the ratio will have units
             of length or units of 1/length.
            
             Warning: You have to manually destroy the gear joint if jointA or jointB is destroyed.
             </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.GearJoint.#ctor(tainicom.Aether.Physics2D.Dynamics.Body,tainicom.Aether.Physics2D.Dynamics.Body,tainicom.Aether.Physics2D.Dynamics.Joints.Joint,tainicom.Aether.Physics2D.Dynamics.Joints.Joint,System.Single)">
            <summary>
            Requires two existing revolute or prismatic joints (any combination will work).
            The provided joints must attach a dynamic body to a static body.
            </summary>
            <param name="jointA">The first joint.</param>
            <param name="jointB">The second joint.</param>
            <param name="ratio">The ratio.</param>
            <param name="bodyA">The first body</param>
            <param name="bodyB">The second body</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.GearJoint.Ratio">
            <summary>
            The gear ratio.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.GearJoint.JointA">
            <summary>
            The first revolute/prismatic joint attached to the gear joint.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.GearJoint.JointB">
            <summary>
            The second revolute/prismatic joint attached to the gear joint.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Joints.JointEdge">
            <summary>
            A joint edge is used to connect bodies and joints together
            in a joint graph where each body is a node and each joint
            is an edge. A joint edge belongs to a doubly linked list
            maintained in each attached body. Each joint has two joint
            nodes, one for each attached body.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.Joints.JointEdge.Joint">
            <summary>
            The joint.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.Joints.JointEdge.Next">
            <summary>
            The next joint edge in the body's joint list.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.Joints.JointEdge.Other">
            <summary>
            Provides quick access to the other body attached.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.Joints.JointEdge.Prev">
            <summary>
            The previous joint edge in the body's joint list.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.Joints.Joint.Enabled">
            <summary>
            Indicate if this join is enabled or not. Disabling a joint
            means it is still in the simulation, but inactive.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.Joint.#ctor(tainicom.Aether.Physics2D.Dynamics.Body)">
            <summary>
            Constructor for fixed joint
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.Joint.World">
            <summary>
            Get the parent World of this joint. This is null if the joint is not attached.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.Joint.JointType">
            <summary>
            Gets or sets the type of the joint.
            </summary>
            <value>The type of the joint.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.Joint.BodyA">
            <summary>
            Get the first body attached to this joint.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.Joint.BodyB">
            <summary>
            Get the second body attached to this joint.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.Joint.WorldAnchorA">
            <summary>
            Get the anchor point on bodyA in world coordinates.
            On some joints, this value indicate the anchor point within the world.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.Joint.WorldAnchorB">
            <summary>
            Get the anchor point on bodyB in world coordinates.
            On some joints, this value indicate the anchor point within the world.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.Joints.Joint.Tag">
            <summary>
            Set the user data pointer.
            </summary>
            <value>The data.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.Joint.CollideConnected">
            <summary>
            Set this flag to true if the attached bodies should collide.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.Joint.Breakpoint">
            <summary>
            The Breakpoint simply indicates the maximum Value the JointError can be before it breaks.
            The default value is float.MaxValue, which means it never breaks.
            </summary>
        </member>
        <member name="E:tainicom.Aether.Physics2D.Dynamics.Joints.Joint.Broke">
            <summary>
            Fires when the joint is broken.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.Joint.GetReactionForce(System.Single)">
            <summary>
            Get the reaction force on body at the joint anchor in Newtons.
            </summary>
            <param name="invDt">The inverse delta time.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.Joint.GetReactionTorque(System.Single)">
            <summary>
            Get the reaction torque on the body at the joint anchor in N*m.
            </summary>
            <param name="invDt">The inverse delta time.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.Joint.IsFixedType">
            <summary>
            Return true if the joint is a fixed type.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.Joint.SolvePositionConstraints(tainicom.Aether.Physics2D.Dynamics.SolverData@)">
            <summary>
            Solves the position constraints.
            </summary>
            <param name="data"></param>
            <returns>returns true if the position errors are within tolerance.</returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Joints.JointFactory">
            <summary>
            An easy to use factory for using joints.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Joints.MotorJoint">
            <summary>
            A motor joint is used to control the relative motion
            between two bodies. A typical usage is to control the movement
            of a dynamic body with respect to the ground.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.MotorJoint.#ctor(tainicom.Aether.Physics2D.Dynamics.Body,tainicom.Aether.Physics2D.Dynamics.Body,System.Boolean)">
            <summary>
            Constructor for MotorJoint.
            </summary>
            <param name="bodyA">The first body</param>
            <param name="bodyB">The second body</param>
            <param name="useWorldCoordinates">Set to true if you are using world coordinates as anchors.</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.MotorJoint.MaxForce">
            <summary>
            The maximum amount of force that can be applied to BodyA
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.MotorJoint.MaxTorque">
            <summary>
            The maximum amount of torque that can be applied to BodyA
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.MotorJoint.LinearOffset">
            <summary>
            The linear (translation) offset.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.MotorJoint.AngularOffset">
            <summary>
            Get or set the angular offset.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Joints.PrismaticJoint">
            <summary>
            A prismatic joint. This joint provides one degree of freedom: translation
            along an axis fixed in bodyA. Relative rotation is prevented. You can
            use a joint limit to restrict the range of motion and a joint motor to
            drive the motion or to model joint friction.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.PrismaticJoint.#ctor(tainicom.Aether.Physics2D.Dynamics.Body,tainicom.Aether.Physics2D.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Boolean)">
            <summary>
            This requires defining a line of
            motion using an axis and an anchor point. The definition uses local
            anchor points and a local axis so that the initial configuration
            can violate the constraint slightly. The joint translation is zero
            when the local anchor points coincide in world space. Using local
            anchors and a local axis helps when saving and loading a game.
            </summary>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <param name="anchorA">The first body anchor.</param>
            <param name="anchorB">The second body anchor.</param>
            <param name="axis">The axis.</param>
            <param name="useWorldCoordinates">Set to true if you are using world coordinates as anchors.</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PrismaticJoint.LocalAnchorA">
            <summary>
            The local anchor point on BodyA
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PrismaticJoint.LocalAnchorB">
            <summary>
            The local anchor point on BodyB
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PrismaticJoint.JointTranslation">
            <summary>
            Get the current joint translation, usually in meters.
            </summary>
            <value></value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PrismaticJoint.JointSpeed">
            <summary>
            Get the current joint translation speed, usually in meters per second.
            </summary>
            <value></value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PrismaticJoint.LimitEnabled">
            <summary>
            Is the joint limit enabled?
            </summary>
            <value><c>true</c> if [limit enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PrismaticJoint.LowerLimit">
            <summary>
            Get the lower joint limit, usually in meters.
            </summary>
            <value></value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PrismaticJoint.UpperLimit">
            <summary>
            Get the upper joint limit, usually in meters.
            </summary>
            <value></value>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.PrismaticJoint.SetLimits(System.Single,System.Single)">
            <summary>
            Set the joint limits, usually in meters.
            </summary>
            <param name="lower">The lower limit</param>
            <param name="upper">The upper limit</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PrismaticJoint.MotorEnabled">
            <summary>
            Is the joint motor enabled?
            </summary>
            <value><c>true</c> if [motor enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PrismaticJoint.MotorSpeed">
            <summary>
            Set the motor speed, usually in meters per second.
            </summary>
            <value>The speed.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PrismaticJoint.MaxMotorForce">
            <summary>
            Set the maximum motor force, usually in N.
            </summary>
            <value>The force.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PrismaticJoint.MotorImpulse">
            <summary>
            Get the current motor impulse, usually in N.
            </summary>
            <value></value>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.PrismaticJoint.GetMotorForce(System.Single)">
            <summary>
            Gets the motor force.
            </summary>
            <param name="invDt">The inverse delta time</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PrismaticJoint.Axis">
            <summary>
            The axis at which the joint moves.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PrismaticJoint.LocalXAxis">
            <summary>
            The axis in local coordinates relative to BodyA
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PrismaticJoint.ReferenceAngle">
            <summary>
            The reference angle.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Joints.PulleyJoint">
            <summary>
            The pulley joint is connected to two bodies and two fixed world points.
            The pulley supports a ratio such that:
            <![CDATA[length1 + ratio * length2 <= constant]]>
            Yes, the force transmitted is scaled by the ratio.
            
            Warning: the pulley joint can get a bit squirrelly by itself. They often
            work better when combined with prismatic joints. You should also cover the
            the anchor points with static shapes to prevent one side from going to zero length.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.PulleyJoint.#ctor(tainicom.Aether.Physics2D.Dynamics.Body,tainicom.Aether.Physics2D.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single,System.Boolean)">
            <summary>
            Constructor for PulleyJoint.
            </summary>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <param name="anchorA">The anchor on the first body.</param>
            <param name="anchorB">The anchor on the second body.</param>
            <param name="worldAnchorA">The world anchor for the first body.</param>
            <param name="worldAnchorB">The world anchor for the second body.</param>
            <param name="ratio">The ratio.</param>
            <param name="useWorldCoordinates">Set to true if you are using world coordinates as anchors.</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PulleyJoint.LocalAnchorA">
            <summary>
            The local anchor point on BodyA
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PulleyJoint.LocalAnchorB">
            <summary>
            The local anchor point on BodyB
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PulleyJoint.WorldAnchorA">
            <summary>
            Get the first world anchor.
            </summary>
            <value></value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PulleyJoint.WorldAnchorB">
            <summary>
            Get the second world anchor.
            </summary>
            <value></value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PulleyJoint.LengthA">
            <summary>
            Get the current length of the segment attached to body1.
            </summary>
            <value></value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PulleyJoint.LengthB">
            <summary>
            Get the current length of the segment attached to body2.
            </summary>
            <value></value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PulleyJoint.CurrentLengthA">
            <summary>
            The current length between the anchor point on BodyA and WorldAnchorA
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PulleyJoint.CurrentLengthB">
            <summary>
            The current length between the anchor point on BodyB and WorldAnchorB
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.PulleyJoint.Ratio">
            <summary>
            Get the pulley ratio.
            </summary>
            <value></value>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Joints.RevoluteJoint">
            <summary>
            A revolute joint constrains to bodies to share a common point while they
            are free to rotate about the point. The relative rotation about the shared
            point is the joint angle. You can limit the relative rotation with
            a joint limit that specifies a lower and upper angle. You can use a motor
            to drive the relative rotation about the shared point. A maximum motor torque
            is provided so that infinite forces are not generated.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.RevoluteJoint.#ctor(tainicom.Aether.Physics2D.Dynamics.Body,tainicom.Aether.Physics2D.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Boolean)">
            <summary>
            Constructor of RevoluteJoint. 
            </summary>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <param name="anchorA">The first body anchor.</param>
            <param name="anchorB">The second anchor.</param>
            <param name="useWorldCoordinates">Set to true if you are using world coordinates as anchors.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.RevoluteJoint.#ctor(tainicom.Aether.Physics2D.Dynamics.Body,tainicom.Aether.Physics2D.Dynamics.Body,Microsoft.Xna.Framework.Vector2,System.Boolean)">
            <summary>
            Constructor of RevoluteJoint. 
            </summary>
            <param name="bodyA">The first body.</param>
            <param name="bodyB">The second body.</param>
            <param name="anchor">The shared anchor.</param>
            <param name="useWorldCoordinates"></param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.RevoluteJoint.LocalAnchorA">
            <summary>
            The local anchor point on BodyA
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.RevoluteJoint.LocalAnchorB">
            <summary>
            The local anchor point on BodyB
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.RevoluteJoint.ReferenceAngle">
            <summary>
            The referance angle computed as BodyB angle minus BodyA angle.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.RevoluteJoint.JointAngle">
            <summary>
            Get the current joint angle in radians.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.RevoluteJoint.JointSpeed">
            <summary>
            Get the current joint angle speed in radians per second.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.RevoluteJoint.LimitEnabled">
            <summary>
            Is the joint limit enabled?
            </summary>
            <value><c>true</c> if [limit enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.RevoluteJoint.LowerLimit">
            <summary>
            Get the lower joint limit in radians.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.RevoluteJoint.UpperLimit">
            <summary>
            Get the upper joint limit in radians.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.RevoluteJoint.SetLimits(System.Single,System.Single)">
            <summary>
            Set the joint limits, usually in meters.
            </summary>
            <param name="lower">The lower limit</param>
            <param name="upper">The upper limit</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.RevoluteJoint.MotorEnabled">
            <summary>
            Is the joint motor enabled?
            </summary>
            <value><c>true</c> if [motor enabled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.RevoluteJoint.MotorSpeed">
            <summary>
            Get or set the motor speed in radians per second.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.RevoluteJoint.MaxMotorTorque">
            <summary>
            Get or set the maximum motor torque, usually in N-m.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.RevoluteJoint.MotorImpulse">
            <summary>
            Get or set the current motor impulse, usually in N-m.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.RevoluteJoint.GetMotorTorque(System.Single)">
            <summary>
            Gets the motor torque in N-m.
            </summary>
            <param name="invDt">The inverse delta time</param>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Joints.RopeJoint">
            <summary>
            A rope joint enforces a maximum distance between two points on two bodies. It has no other effect.
            It can be used on ropes that are made up of several connected bodies, and if there is a need to support a heavy body.
            This joint is used for stabiliation of heavy objects on soft constraint joints.
            
            Warning: if you attempt to change the maximum length during the simulation you will get some non-physical behavior.
            Use the DistanceJoint instead if you want to dynamically control the length.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.RopeJoint.#ctor(tainicom.Aether.Physics2D.Dynamics.Body,tainicom.Aether.Physics2D.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Boolean)">
            <summary>
            Constructor for RopeJoint.
            </summary>
            <param name="bodyA">The first body</param>
            <param name="bodyB">The second body</param>
            <param name="anchorA">The anchor on the first body</param>
            <param name="anchorB">The anchor on the second body</param>
            <param name="useWorldCoordinates">Set to true if you are using world coordinates as anchors.</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.RopeJoint.LocalAnchorA">
            <summary>
            The local anchor point on BodyA
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.RopeJoint.LocalAnchorB">
            <summary>
            The local anchor point on BodyB
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.RopeJoint.MaxLength">
            <summary>
            Get or set the maximum length of the rope.
            By default, it is the distance between the two anchor points.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.RopeJoint.State">
            <summary>
            Gets the state of the joint.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Joints.WeldJoint">
            <summary>
            A weld joint essentially glues two bodies together. A weld joint may
            distort somewhat because the island constraint solver is approximate.
            
            The joint is soft constraint based, which means the two bodies will move
            relative to each other, when a force is applied. To combine two bodies
            in a rigid fashion, combine the fixtures to a single body instead.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.WeldJoint.#ctor(tainicom.Aether.Physics2D.Dynamics.Body,tainicom.Aether.Physics2D.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Boolean)">
            <summary>
            You need to specify an anchor point where they are attached.
            The position of the anchor point is important for computing the reaction torque.
            </summary>
            <param name="bodyA">The first body</param>
            <param name="bodyB">The second body</param>
            <param name="anchorA">The first body anchor.</param>
            <param name="anchorB">The second body anchor.</param>
            <param name="useWorldCoordinates">Set to true if you are using world coordinates as anchors.</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.WeldJoint.LocalAnchorA">
            <summary>
            The local anchor point on BodyA
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.WeldJoint.LocalAnchorB">
            <summary>
            The local anchor point on BodyB
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.WeldJoint.ReferenceAngle">
            <summary>
            The bodyB angle minus bodyA angle in the reference state (radians).
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.WeldJoint.FrequencyHz">
            <summary>
            The frequency of the joint. A higher frequency means a stiffer joint, but
            a too high value can cause the joint to oscillate.
            Default is 0, which means the joint does no spring calculations.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.WeldJoint.DampingRatio">
            <summary>
            The damping on the joint. The damping is only used when
            the joint has a frequency (> 0). A higher value means more damping.
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.Joints.WheelJoint">
            <summary>
            A wheel joint. This joint provides two degrees of freedom: translation
            along an axis fixed in bodyA and rotation in the plane. You can use a
            joint limit to restrict the range of motion and a joint motor to drive
            the rotation or to model rotational friction.
            This joint is designed for vehicle suspensions.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.WheelJoint.#ctor(tainicom.Aether.Physics2D.Dynamics.Body,tainicom.Aether.Physics2D.Dynamics.Body,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Boolean)">
            <summary>
            Constructor for WheelJoint
            </summary>
            <param name="bodyA">The first body</param>
            <param name="bodyB">The second body</param>
            <param name="anchor">The anchor point</param>
            <param name="axis">The axis</param>
            <param name="useWorldCoordinates">Set to true if you are using world coordinates as anchors.</param>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.WheelJoint.LocalAnchorA">
            <summary>
            The local anchor point on BodyA
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.WheelJoint.LocalAnchorB">
            <summary>
            The local anchor point on BodyB
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.WheelJoint.Axis">
            <summary>
            The axis at which the suspension moves.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.WheelJoint.LocalXAxis">
            <summary>
            The axis in local coordinates relative to BodyA
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.WheelJoint.MotorSpeed">
            <summary>
            The desired motor speed in radians per second.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.WheelJoint.MaxMotorTorque">
            <summary>
            The maximum motor torque, usually in N-m.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.WheelJoint.Frequency">
            <summary>
            Suspension frequency, zero indicates no suspension
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.WheelJoint.DampingRatio">
            <summary>
            Suspension damping ratio, one indicates critical damping
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.WheelJoint.JointTranslation">
            <summary>
            Gets the translation along the axis
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.WheelJoint.JointSpeed">
            <summary>
            Gets the angular velocity of the joint
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.Joints.WheelJoint.MotorEnabled">
            <summary>
            Enable/disable the joint motor.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.Joints.WheelJoint.GetMotorTorque(System.Single)">
            <summary>
            Gets the torque of the motor
            </summary>
            <param name="invDt">inverse delta time</param>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.SolverIterations.VelocityIterations">
            <summary>The number of velocity iterations used in the solver.</summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.SolverIterations.PositionIterations">
            <summary>The number of position iterations used in the solver.</summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.SolverIterations.TOIVelocityIterations">
            <summary>The number of velocity iterations in the TOI solver</summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.SolverIterations.TOIPositionIterations">
            <summary>The number of position iterations in the TOI solver</summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.TimeStep">
            <summary>
            This is an internal structure.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.TimeStep.dt">
            <summary>
            Time step (Delta time)
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.TimeStep.dtRatio">
            <summary>
            dt * inv_dt0
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.TimeStep.inv_dt">
            <summary>
            Inverse time step (0 if dt == 0).
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.SolverPosition">
            This is an internal structure.
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.SolverVelocity">
            This is an internal structure.
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.SolverData">
            Solver Data
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.World">
            <summary>
            The world class manages all physics entities, dynamic simulation,
            and asynchronous queries.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.World._warmStarting">
            <summary>This is only for debugging the solver</summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.World._subStepping">
            <summary>This is only for debugging the solver</summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.World.Tag">
            <summary>
            Set the user data. Use this to store your application specific data.
            </summary>
            <value>The user data.</value>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.World.BodyAdded">
            <summary>
            Fires whenever a body has been added
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.World.BodyRemoved">
            <summary>
            Fires whenever a body has been removed
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.World.FixtureAdded">
            <summary>
            Fires whenever a fixture has been added
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.World.FixtureRemoved">
            <summary>
            Fires whenever a fixture has been removed
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.World.JointAdded">
            <summary>
            Fires whenever a joint has been added
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.World.JointRemoved">
            <summary>
            Fires whenever a joint has been removed
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.World.ControllerAdded">
            <summary>
            Fires every time a controller is added to the World.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.World.ControllerRemoved">
            <summary>
            Fires every time a controlelr is removed form the World.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:tainicom.Aether.Physics2D.Dynamics.World"/> class.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.#ctor(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Initializes a new instance of the <see cref="T:tainicom.Aether.Physics2D.Dynamics.World"/> class.
            </summary>
            <param name="gravity">The gravity.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.#ctor(tainicom.Aether.Physics2D.Collision.IBroadPhase)">
            <summary>
            Initializes a new instance of the <see cref="T:tainicom.Aether.Physics2D.Dynamics.World"/> class.
            </summary>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.World.ProxyCount">
            <summary>
            Get the number of broad-phase proxies.
            </summary>
            <value>The proxy count.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.World.ContactCount">
            <summary>
            Get the number of contacts (each may have 0 or more contact points).
            </summary>
            <value>The contact count.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.World.Gravity">
            <summary>
            Change the global gravity vector.
            </summary>
            <value>The gravity.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.World.IsLocked">
            <summary>
            Is the world locked (in the middle of a time step).
            </summary>        
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.World.ContactManager">
            <summary>
            Get the contact manager for testing.
            </summary>
            <value>The contact manager.</value>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.World.BodyList">
            <summary>
            Get the world body list.
            </summary>
            <value>The head of the world body list.</value>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Dynamics.World.JointList">
            <summary>
            Get the world joint list. 
            </summary>
            <value>The joint list.</value>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.World.ContactList">
            <summary>
            Get the world contact list. 
            ContactList is the head of a circular linked list. Use Contact.Next to get
            the next contact in the world list. A contact equal to ContactList indicates the end of the list.
            </summary>
            <value>The head of the world contact list.</value>
            <example>for (Contact c = World.ContactList.Next; c != World..ContactList; c = c.Next)</example>
        </member>
        <member name="P:tainicom.Aether.Physics2D.Dynamics.World.Enabled">
            <summary>
            If false, the whole simulation stops. It still processes added and removed geometries.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.Add(tainicom.Aether.Physics2D.Dynamics.Body)">
            <summary>
            Add a rigid body.
            Warning: This method is locked during callbacks.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.Remove(tainicom.Aether.Physics2D.Dynamics.Body)">
            <summary>
            Destroy a rigid body.
            Warning: This automatically deletes all associated shapes and joints.
            Warning: This method is locked during callbacks.
            </summary>
            <param name="body">The body.</param>
            <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.Add(tainicom.Aether.Physics2D.Dynamics.Joints.Joint)">
            <summary>
            Create a joint to constrain bodies together. This may cause the connected bodies to cease colliding.
            Warning: This method is locked during callbacks.
            </summary>
            <param name="joint">The joint.</param>
            <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.Remove(tainicom.Aether.Physics2D.Dynamics.Joints.Joint)">
            <summary>
            Destroy a joint. This may cause the connected bodies to begin colliding.
            Warning: This method is locked during callbacks.
            </summary>
            <param name="joint">The joint.</param>
            <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.AddAsync(tainicom.Aether.Physics2D.Dynamics.Body)">
            <summary>
            Add a rigid body.
            </summary>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.RemoveAsync(tainicom.Aether.Physics2D.Dynamics.Body)">
            <summary>
            Destroy a rigid body.
            Warning: This automatically deletes all associated shapes and joints.
            </summary>
            <param name="body">The body.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.AddAsync(tainicom.Aether.Physics2D.Dynamics.Joints.Joint)">
            <summary>
            Create a joint to constrain bodies together. This may cause the connected bodies to cease colliding.
            </summary>
            <param name="joint">The joint.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.RemoveAsync(tainicom.Aether.Physics2D.Dynamics.Joints.Joint)">
            <summary>
            Destroy a joint. This may cause the connected bodies to begin colliding.
            </summary>
            <param name="joint">The joint.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.ProcessChanges">
            <summary>
            All Async adds and removes are cached by the World during a World step.
            To process the changes before the world updates again, call this method.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.Step(System.TimeSpan)">
            <summary>
            Take a time step. This performs collision detection, integration,
            and consraint solution.
            </summary>
            <param name="dt">The amount of time to simulate, this should not vary.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.Step(System.TimeSpan,tainicom.Aether.Physics2D.Dynamics.SolverIterations@)">
            <summary>
            Take a time step. This performs collision detection, integration,
            and consraint solution.
            </summary>
            <param name="dt">The amount of time to simulate, this should not vary.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.Step(System.Single)">
            <summary>
            Take a time step. This performs collision detection, integration,
            and consraint solution.
            Warning: This method is locked during callbacks.
            </summary>
            <param name="dt">The amount of time to simulate in seconds, this should not vary.</param>
            <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.Step(System.Single,tainicom.Aether.Physics2D.Dynamics.SolverIterations@)">
            <summary>
            Take a time step. This performs collision detection, integration,
            and consraint solution.
            Warning: This method is locked during callbacks.
            </summary>
            <param name="dt">The amount of time to simulate in seconds, this should not vary.</param>
            <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.ClearForces">
            <summary>
            Call this after you are done with time steps to clear the forces. You normally
            call this after each call to Step, unless you are performing sub-steps. By default,
            forces will be automatically cleared, so you don't need to call this function.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.QueryAABB(tainicom.Aether.Physics2D.Dynamics.QueryReportFixtureDelegate,tainicom.Aether.Physics2D.Collision.AABB)">
            <summary>
            Query the world for all fixtures that potentially overlap the provided AABB.
            
            Inside the callback:
            Return true: Continues the query
            Return false: Terminate the query
            </summary>
            <param name="callback">A user implemented callback class.</param>
            <param name="aabb">The aabb query box.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.QueryAABB(tainicom.Aether.Physics2D.Dynamics.QueryReportFixtureDelegate,tainicom.Aether.Physics2D.Collision.AABB@)">
            <summary>
            Query the world for all fixtures that potentially overlap the provided AABB.
            
            Inside the callback:
            Return true: Continues the query
            Return false: Terminate the query
            </summary>
            <param name="callback">A user implemented callback class.</param>
            <param name="aabb">The aabb query box.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.RayCast(tainicom.Aether.Physics2D.Dynamics.RayCastReportFixtureDelegate,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Ray-cast the world for all fixtures in the path of the ray. Your callback
            controls whether you get the closest point, any point, or n-points.
            The ray-cast ignores shapes that contain the starting point.
            
            Inside the callback:
            return -1: ignore this fixture and continue
            return 0: terminate the ray cast
            return fraction: clip the ray to this point
            return 1: don't clip the ray and continue
            </summary>
            <param name="callback">A user implemented callback class.</param>
            <param name="point1">The ray starting point.</param>
            <param name="point2">The ray ending point.</param>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.Add(tainicom.Aether.Physics2D.Controllers.Controller)">
            <summary>
            Warning: This method is locked during callbacks.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.Remove(tainicom.Aether.Physics2D.Controllers.Controller)">
            <summary>
            Warning: This method is locked during callbacks.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.ShiftOrigin(Microsoft.Xna.Framework.Vector2)">
            Shift the world origin. Useful for large worlds.
            The body shift formula is: position -= newOrigin
            @param newOrigin the new origin with respect to the old origin
            Warning: Calling this method mid-update might cause a crash.
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.Clear">
            <summary>
            Warning: This method is locked during callbacks.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when the world is Locked/Stepping.</exception>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Dynamics.World.CreateChain(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single,System.Single,System.Int32,System.Single,System.Boolean)">
            <summary>
            Creates a chain.
            </summary>
            <param name="world">The world.</param>
            <param name="start">The start.</param>
            <param name="end">The end.</param>
            <param name="linkWidth">The width.</param>
            <param name="linkHeight">The height.</param>
            <param name="numberOfLinks">The number of links.</param>
            <param name="linkDensity">The link density.</param>
            <param name="attachRopeJoint">Creates a rope joint between start and end. This enforces the length of the rope. Said in another way: it makes the rope less bouncy.</param>
            <returns></returns>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.QueryReportFixtureDelegate">
            <summary>
            Called for each fixture found in the query.
            <returns>true: Continues the query, false: Terminate the query</returns>
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.RayCastReportFixtureDelegate">
            <summary>
            Called for each fixture found in the query. You control how the ray cast
            proceeds by returning a float:
            return -1: ignore this fixture and continue
            return 0: terminate the ray cast
            return fraction: clip the ray to this point
            return 1: don't clip the ray and continue
            @param fixture the fixture hit by the ray
            @param point the point of initial intersection
            @param normal the normal vector at the point of intersection
            @return 0 to terminate, fraction to clip the ray for closest hit, 1 to continue
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.EndContactDelegate">
            <summary>
            This delegate is called when a contact is deleted
            </summary>
        </member>
        <member name="T:tainicom.Aether.Physics2D.Dynamics.BeginContactDelegate">
            <summary>
            This delegate is called when a contact is created
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.EnableDiagnostics">
            <summary>
            Enabling diagnistics causes the engine to gather timing information.
            You can see how much time it took to solve the contacts, solve CCD
            and update the controllers.
            NOTE: If you are using a debug view that shows performance counters,
            you might want to enable this.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.VelocityIterations">
            <summary>
            The number of velocity iterations used in the solver.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.PositionIterations">
            <summary>
            The number of position iterations used in the solver.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.ContinuousPhysics">
            <summary>
            Enable/Disable Continuous Collision Detection (CCD)
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.UseConvexHullPolygons">
            <summary>
            If true, it will run a GiftWrap convex hull on all polygon inputs.
            This makes for a more stable engine when given random input,
            but if speed of the creation of polygons are more important,
            you might want to set this to false.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.TOIVelocityIterations">
            <summary>
            The number of velocity iterations in the TOI solver
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.TOIPositionIterations">
            <summary>
            The number of position iterations in the TOI solver
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.MaxSubSteps">
            <summary>
            Maximum number of sub-steps per contact in continuous physics simulation.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.AllowSleep">
            <summary>
            Enable/Disable sleeping
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.MaxPolygonVertices">
            <summary>
            The maximum number of vertices on a convex polygon.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.MaxManifoldPoints">
            <summary>
            The maximum number of contact points between two convex shapes.
            DO NOT CHANGE THIS VALUE!
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.AABBExtension">
            <summary>
            This is used to fatten AABBs in the dynamic tree. This allows proxies
            to move by a small amount without triggering a tree adjustment.
            This is in meters.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.AABBMultiplier">
            <summary>
            This is used to fatten AABBs in the dynamic tree. This is used to predict
            the future position based on the current displacement.
            This is a dimensionless multiplier.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.LinearSlop">
            <summary>
            A small length used as a collision and constraint tolerance. Usually it is
            chosen to be numerically significant, but visually insignificant.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.AngularSlop">
            <summary>
            A small angle used as a collision and constraint tolerance. Usually it is
            chosen to be numerically significant, but visually insignificant.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.PolygonRadius">
            <summary>
            The radius of the polygon/edge shape skin. This should not be modified. Making
            this smaller means polygons will have an insufficient buffer for continuous collision.
            Making it larger may create artifacts for vertex collision.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.MaxTOIContacts">
            <summary>
            Maximum number of contacts to be handled to solve a TOI impact.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.VelocityThreshold">
            <summary>
            A velocity threshold for elastic collisions. Any collision with a relative linear
            velocity below this threshold will be treated as inelastic.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.MaxLinearCorrection">
            <summary>
            The maximum linear position correction used when solving constraints. This helps to
            prevent overshoot.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.MaxAngularCorrection">
            <summary>
            The maximum angular position correction used when solving constraints. This helps to
            prevent overshoot.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.Baumgarte">
            <summary>
            This scale factor controls how fast overlap is resolved. Ideally this would be 1 so
            that overlap is removed in one time step. However using values close to 1 often lead
            to overshoot.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.TimeToSleep">
            <summary>
            The time that a body must be still before it will go to sleep.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.LinearSleepTolerance">
            <summary>
            A body cannot sleep if its linear velocity is above this tolerance.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.AngularSleepTolerance">
            <summary>
            A body cannot sleep if its angular velocity is above this tolerance.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.MaxTranslation">
            <summary>
            The maximum linear velocity of a body. This limit is very large and is used
            to prevent numerical problems. You shouldn't need to adjust this.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.MaxRotation">
            <summary>
            The maximum angular velocity of a body. This limit is very large and is used
            to prevent numerical problems. You shouldn't need to adjust this.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.MaxGJKIterations">
            <summary>
            Defines the maximum number of iterations made by the GJK algorithm.
            </summary>
        </member>
        <member name="F:tainicom.Aether.Physics2D.Settings.AutoClearForces">
            <summary>
            By default, forces are cleared automatically after each call to Step.
            The default behavior is modified with this setting.
            The purpose of this setting is to support sub-stepping. Sub-stepping is often used to maintain
            a fixed sized time step under a variable frame-rate.
            When you perform sub-stepping you should disable auto clearing of forces and instead call
            ClearForces after all sub-steps are complete in one pass of your game loop.
            </summary>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Settings.MixFriction(System.Single,System.Single)">
            <summary>
            Friction mixing law. Feel free to customize this.
            </summary>
            <param name="friction1">The friction1.</param>
            <param name="friction2">The friction2.</param>
            <returns></returns>
        </member>
        <member name="M:tainicom.Aether.Physics2D.Settings.MixRestitution(System.Single,System.Single)">
            <summary>
            Restitution mixing law. Feel free to customize this.
            </summary>
            <param name="restitution1">The restitution1.</param>
            <param name="restitution2">The restitution2.</param>
            <returns></returns>
        </member>
    </members>
</doc>
